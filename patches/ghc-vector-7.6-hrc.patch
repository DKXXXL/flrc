diff --git a/Data/Vector.hs b/Data/Vector.hs
index 7fac580..3f91f21 100644
--- a/Data/Vector.hs
+++ b/Data/Vector.hs
@@ -153,7 +153,7 @@ module Data.Vector (
 
 import qualified Data.Vector.Generic as G
 import           Data.Vector.Mutable  ( MVector(..) )
-import           Data.Primitive.Array
+import           Data.Primitive.ImmutableArray
 import qualified Data.Vector.Fusion.Stream as Stream
 
 import Control.Monad ( MonadPlus(..), liftM, ap )
@@ -188,7 +188,7 @@ import qualified Data.Traversable as Traversable
 -- | Boxed vectors, supporting efficient slicing.
 data Vector a = Vector {-# UNPACK #-} !Int
                        {-# UNPACK #-} !Int
-                       {-# UNPACK #-} !(Array a)
+                       {-# UNPACK #-} !(ImmutableArray a)
         deriving ( Typeable )
 
 instance Show a => Show (Vector a) where
@@ -208,13 +208,14 @@ instance Data a => Data (Vector a) where
 type instance G.Mutable Vector = MVector
 
 instance G.Vector Vector a where
-  {-# INLINE basicUnsafeFreeze #-}
-  basicUnsafeFreeze (MVector i n marr)
-    = Vector i n `liftM` unsafeFreezeArray marr
+  {-# INLINE basicUnsafeCreate #-}
+  basicUnsafeCreate n = do {arr <- newImmutableArray n; return $ Vector 0 n arr}
 
-  {-# INLINE basicUnsafeThaw #-}
-  basicUnsafeThaw (Vector i n arr)
-    = MVector i n `liftM` unsafeThawArray arr
+  {-# INLINE basicUnsafeInitElem #-}
+  basicUnsafeInitElem (Vector j _ arr) i x = initImmutableArray arr (i+j) x
+
+  {-# INLINE basicUnsafeInited #-}
+  basicUnsafeInited (Vector i n arr) = do {arr' <- immutableArrayInited arr; return $ Vector i n arr'}
 
   {-# INLINE basicLength #-}
   basicLength (Vector _ n _) = n
@@ -223,11 +224,7 @@ instance G.Vector Vector a where
   basicUnsafeSlice j n (Vector i _ arr) = Vector (i+j) n arr
 
   {-# INLINE basicUnsafeIndexM #-}
-  basicUnsafeIndexM (Vector i _ arr) j = indexArrayM arr (i+j)
-
-  {-# INLINE basicUnsafeCopy #-}
-  basicUnsafeCopy (MVector i n dst) (Vector j _ src)
-    = copyArray dst i src j n
+  basicUnsafeIndexM (Vector i _ arr) j = indexImmutableArrayM arr (i+j)
 
 -- See http://trac.haskell.org/vector/ticket/12
 instance Eq a => Eq (Vector a) where
diff --git a/Data/Vector/Generic.hs b/Data/Vector/Generic.hs
index b8f2e81..6ee747a 100644
--- a/Data/Vector/Generic.hs
+++ b/Data/Vector/Generic.hs
@@ -220,6 +220,9 @@ length v = basicLength v
 "length/unstream [Vector]" forall s.
   length (new (New.unstream s)) = Stream.length s
 
+"length/unstream [Vector_FLRC]" forall s.
+  length (unstream s) = Stream.length s
+
   #-}
 
 -- | /O(1)/ Test whether a vector if empty
@@ -232,6 +235,9 @@ null v = basicLength v == 0
 "null/unstream [Vector]" forall s.
   null (new (New.unstream s)) = Stream.null s
 
+"null/unstream [Vector_FLRC]" forall s.
+  null (unstream s) = Stream.null s
+
   #-}
 
 -- Indexing
@@ -282,24 +288,45 @@ unsafeLast v = unsafeIndex v (length v - 1)
 "(!)/unstream [Vector]" forall i s.
   new (New.unstream s) ! i = s Stream.!! i
 
+"(!)/unstream [Vector_FLRC]" forall i s.
+  unstream s ! i = s Stream.!! i
+
 "(!?)/unstream [Vector]" forall i s.
   new (New.unstream s) !? i = s Stream.!? i
 
+"(!?)/unstream [Vector_FLRC]" forall i s.
+  unstream s !? i = s Stream.!? i
+
 "head/unstream [Vector]" forall s.
   head (new (New.unstream s)) = Stream.head s
 
+"head/unstream [Vector_FLRC]" forall s.
+  head (unstream s) = Stream.head s
+
 "last/unstream [Vector]" forall s.
   last (new (New.unstream s)) = Stream.last s
 
+"last/unstream [Vector_FLRC]" forall s.
+  last (unstream s) = Stream.last s
+
 "unsafeIndex/unstream [Vector]" forall i s.
   unsafeIndex (new (New.unstream s)) i = s Stream.!! i
 
+"unsafeIndex/unstream [Vector_FLRC]" forall i s.
+  unsafeIndex (unstream s) i = s Stream.!! i
+
 "unsafeHead/unstream [Vector]" forall s.
   unsafeHead (new (New.unstream s)) = Stream.head s
 
+"unsafeHead/unstream [Vector_FLRC]" forall s.
+  unsafeHead (unstream s) = Stream.head s
+
 "unsafeLast/unstream [Vector]" forall s.
   unsafeLast (new (New.unstream s)) = Stream.last s
 
+"unsafeLast/unstream [Vector_FLRC]" forall s.
+  unsafeLast (unstream s) = Stream.last s
+
  #-}
 
 -- Monadic indexing
@@ -365,21 +392,39 @@ unsafeLastM v = unsafeIndexM v (length v - 1)
 "indexM/unstream [Vector]" forall s i.
   indexM (new (New.unstream s)) i = liftStream s MStream.!! i
 
+"indexM/unstream [Vector_FLRC]" forall s i.
+  indexM (unstream s) i = liftStream s MStream.!! i
+
 "headM/unstream [Vector]" forall s.
   headM (new (New.unstream s)) = MStream.head (liftStream s)
 
+"headM/unstream [Vector_FLRC]" forall s.
+  headM (unstream s) = MStream.head (liftStream s)
+
 "lastM/unstream [Vector]" forall s.
   lastM (new (New.unstream s)) = MStream.last (liftStream s)
 
+"lastM/unstream [Vector_FLRC]" forall s.
+  lastM (unstream s) = MStream.last (liftStream s)
+
 "unsafeIndexM/unstream [Vector]" forall s i.
   unsafeIndexM (new (New.unstream s)) i = liftStream s MStream.!! i
 
+"unsafeIndexM/unstream [Vector_FLRC]" forall s i.
+  unsafeIndexM (unstream s) i = liftStream s MStream.!! i
+
 "unsafeHeadM/unstream [Vector]" forall s.
   unsafeHeadM (new (New.unstream s)) = MStream.head (liftStream s)
 
+"unsafeHeadM/unstream [Vector_FLRC]" forall s.
+  unsafeHeadM (unstream s) = MStream.head (liftStream s)
+
 "unsafeLastM/unstream [Vector]" forall s.
   unsafeLastM (new (New.unstream s)) = MStream.last (liftStream s)
 
+"unsafeLastM/unstream [Vector_FLRC]" forall s.
+  unsafeLastM (unstream s) = MStream.last (liftStream s)
+
   #-}
 
 -- Extracting subvectors (slicing)
@@ -732,7 +777,12 @@ force :: Vector v a => v a -> v a
 -- FIXME: we probably ought to inline this later as the rules still might fire
 -- otherwise
 {-# INLINE_STREAM force #-}
-force v = new (clone v)
+force v =
+  v `seq` runST $ do
+    v' <- unsafeCreate (length v)
+    unsafeCopyI v' v
+    v'' <- basicUnsafeInited v'
+    return v''
 
 -- Bulk updates
 -- ------------
@@ -1277,12 +1327,68 @@ partition f = partition_stream f . stream
 
 partition_stream :: Vector v a => (a -> Bool) -> Stream a -> (v a, v a)
 {-# INLINE_STREAM partition_stream #-}
-partition_stream f s = s `seq` runST (
+partition_stream f s = s `seq` runST (partitionStream f s)
+
+partitionStream :: (PrimMonad m, Vector v a) => (a -> Bool) -> Stream a -> m (v a, v a)
+{-# INLINE partitionStream #-}
+partitionStream f s =
+  case upperBound (Stream.size s) of
+    Just n  -> partitionMax f s n
+    Nothing -> partitionUnknown f s
+
+partitionMax :: (PrimMonad m, Vector v a) => (a -> Bool) -> Stream a -> Int -> m (v a, v a)
+{-# INLINE partitionMax #-}
+partitionMax f s n
+  = do
+      v <- INTERNAL_CHECK(checkLength) "partitionMax" n
+         $ unsafeCreate n
+
+      let {-# INLINE_INNER put #-}
+          put (i,j) x
+            | f x       = do
+                            unsafeInitElem v i x
+                            return (i+1,j)
+
+            | otherwise = let j' = j-1 in
                           do
-    (mv1,mv2) <- M.partitionStream f s
-    v1 <- unsafeFreeze mv1
-    v2 <- unsafeFreeze mv2
-    return (v1,v2))
+                            unsafeInitElem v j' x
+                            return (i,j')
+
+      (i,j) <- Stream.foldM' put (0,n) s
+      v' <- basicUnsafeInited v
+      INTERNAL_CHECK(check) "partitionMax" "invalid indices" (i <= j)
+        $ return ()
+      let l  = unsafeSlice 0 i v'
+          r  = unsafeSlice j (n-j) v'
+          r' = reverse r
+      return (l,r')
+
+partitionUnknown :: (PrimMonad m, Vector v a)
+        => (a -> Bool) -> Stream a -> m (v a, v a)
+{-# INLINE partitionUnknown #-}
+partitionUnknown f s
+  = do
+      v1 <- unsafeCreate 0
+      v2 <- unsafeCreate 0
+      (v1', n1, v2', n2) <- Stream.foldM' put (v1, 0, v2, 0) s
+      v1'' <- basicUnsafeInited v1'
+      v2'' <- basicUnsafeInited v2'
+      INTERNAL_CHECK(checkSlice) "partitionUnknown" 0 n1 (length v1'')
+        $ INTERNAL_CHECK(checkSlice) "partitionUnknown" 0 n2 (length v2'')
+        $ return (unsafeSlice 0 n1 v1'', unsafeSlice 0 n2 v2'')
+  where
+    -- NOTE: The case distinction has to be on the outside because
+    -- GHC creates a join point for the unsafeWrite even when everything
+    -- is inlined. This is bad because with the join point, v isn't getting
+    -- unboxed.
+    {-# INLINE_INNER put #-}
+    put (v1, i1, v2, i2) x
+      | f x       = do
+                      v1' <- unsafeAppend1 v1 i1 x
+                      return (v1', i1+1, v2, i2)
+      | otherwise = do
+                      v2' <- unsafeAppend1 v2 i2 x
+                      return (v1, i1, v2', i2+1)
 
 -- | /O(n)/ Split the vector in two parts, the first one containing those
 -- elements that satisfy the predicate and the second one those that don't.
@@ -1295,12 +1401,35 @@ unstablePartition f = unstablePartition_stream f . stream
 unstablePartition_stream
   :: Vector v a => (a -> Bool) -> Stream a -> (v a, v a)
 {-# INLINE_STREAM unstablePartition_stream #-}
-unstablePartition_stream f s = s `seq` runST (
-  do
-    (mv1,mv2) <- M.unstablePartitionStream f s
-    v1 <- unsafeFreeze mv1
-    v2 <- unsafeFreeze mv2
-    return (v1,v2))
+unstablePartition_stream f s = s `seq` runST (unstablePartitionStream f s)
+
+unstablePartitionStream :: (PrimMonad m, Vector v a)
+        => (a -> Bool) -> Stream a -> m (v a, v a)
+{-# INLINE unstablePartitionStream #-}
+unstablePartitionStream f s
+  = case upperBound (Stream.size s) of
+      Just n  -> unstablePartitionMax f s n
+      Nothing -> partitionUnknown f s
+
+unstablePartitionMax :: (PrimMonad m, Vector v a)
+        => (a -> Bool) -> Stream a -> Int -> m (v a, v a)
+{-# INLINE unstablePartitionMax #-}
+unstablePartitionMax f s n
+  = do
+      v <- INTERNAL_CHECK(checkLength) "unstablePartitionMax" n
+           $ unsafeCreate n
+      let {-# INLINE_INNER put #-}
+          put (i, j) x
+            | f x       = do
+                            unsafeInitElem v i x
+                            return (i+1, j)
+            | otherwise = do
+                            unsafeInitElem v (j-1) x
+                            return (i, j-1)
+
+      (i,j) <- Stream.foldM' put (0, n) s
+      v' <- basicUnsafeInited v
+      return (unsafeSlice 0 i v', unsafeSlice j (n-j) v')
 
 unstablePartition_new :: Vector v a => (a -> Bool) -> New v a -> (v a, v a)
 {-# INLINE_STREAM unstablePartition_new #-}
@@ -1308,7 +1437,7 @@ unstablePartition_new f (New.New p) = runST (
   do
     mv <- p
     i <- M.unstablePartition f mv
-    v <- unsafeFreeze mv
+    v <- freeze mv  -- NG: changed to freeze since unsafeFreeze is not implemented
     return (unsafeTake i v, unsafeDrop i v))
 
 {-# RULES
@@ -1767,18 +1896,13 @@ convert = unstream . stream
 unsafeFreeze
   :: (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m (v a)
 {-# INLINE unsafeFreeze #-}
-unsafeFreeze = basicUnsafeFreeze
-
--- | /O(n)/ Yield an immutable copy of the mutable vector.
-freeze :: (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m (v a)
-{-# INLINE freeze #-}
-freeze mv = unsafeFreeze =<< M.clone mv
+unsafeFreeze = freeze -- error "unsafeFreeze unimplemented in hrc"
 
 -- | /O(1)/ Unsafely convert an immutable vector to a mutable one without
 -- copying. The immutable vector may not be used after this operation.
 unsafeThaw :: (PrimMonad m, Vector v a) => v a -> m (Mutable v (PrimState m) a)
 {-# INLINE_STREAM unsafeThaw #-}
-unsafeThaw = basicUnsafeThaw
+unsafeThaw = thaw -- error "unsafeThaw unimplemented in hrc"
 
 -- | /O(n)/ Yield a mutable copy of the immutable vector.
 thaw :: (PrimMonad m, Vector v a) => v a -> m (Mutable v (PrimState m) a)
@@ -1798,6 +1922,19 @@ thaw v = do
 
   #-}
 
+-- | /O(n)/ Yield an immutable copy of the mutable vector.
+freeze :: (PrimMonad m, Vector v a) => Mutable v (PrimState m) a -> m (v a)
+{-# INLINE freeze #-}
+freeze mv =
+  do
+    let n = M.length mv
+    v <- unsafeCreate n
+    let loop i | i<n       = do {x <- M.read mv i; unsafeInitElem v i x; loop (i+1)}
+               | otherwise = return ()
+    loop 0
+    v' <- basicUnsafeInited v
+    return v'
+
 {-
 -- | /O(n)/ Yield a mutable vector containing copies of each vector in the
 -- list.
@@ -1839,6 +1976,15 @@ unsafeCopy dst src = UNSAFE_CHECK(check) "unsafeCopy" "length mismatch"
                                          (M.length dst == length src)
                    $ (dst `seq` src `seq` basicUnsafeCopy dst src)
 
+-- | /O(n)/ Copy an immutable vector into a mutable one. The two vectors must
+-- have the same length. This is not checked.
+unsafeCopyI
+  :: (PrimMonad m, Vector v a) => v a -> v a -> m ()
+{-# INLINE unsafeCopyI #-}
+unsafeCopyI dst src = UNSAFE_CHECK(check) "unsafeCopyI" "length mismatch"
+                                          (length dst == length src)
+                    $ (dst `seq` src `seq` basicUnsafeCopyI dst src)
+
 -- Conversions to/from Streams
 -- ---------------------------
 
@@ -1855,16 +2001,26 @@ stream v = v `seq` n `seq` (Stream.unfoldr get 0 `Stream.sized` Exact n)
     get i | i >= n    = Nothing
           | otherwise = case basicUnsafeIndexM v i of Box x -> Just (x, i+1)
 
+
+-- I've turned this into INLINE_STREAM and made new rules for it.
+-- Basically, rules that had the pattern new (New.unstream s) now
+-- have that pattern replaced with unstream.  It's possible that
+-- the liftStream should be pulled out of the unstream and exposed
+-- to fusion - not sure about this.  -leaf
+
 -- | /O(n)/ Construct a vector from a 'Stream'
 unstream :: Vector v a => Stream a -> v a
-{-# INLINE unstream #-}
-unstream s = new (New.unstream s)
+{-# INLINE_STREAM unstream #-}
+unstream s = runST (unstreamPrimM (Stream.liftStream s))
 
 {-# RULES
 
 "stream/unstream [Vector]" forall s.
   stream (new (New.unstream s)) = s
 
+"stream/unstream [Vector_FLRC]" forall s.
+  stream (unstream s) = s
+
 "New.unstream/stream [Vector]" forall v.
   New.unstream (stream v) = clone v
 
@@ -1894,16 +2050,21 @@ streamR v = v `seq` n `seq` (Stream.unfoldr get n `Stream.sized` Exact n)
             in
             case basicUnsafeIndexM v i' of Box x -> Just (x, i')
 
+-- See comment on unstream -leaf
+
 -- | /O(n)/ Construct a vector from a 'Stream', proceeding from right to left
 unstreamR :: Vector v a => Stream a -> v a
-{-# INLINE unstreamR #-}
-unstreamR s = new (New.unstreamR s)
+{-# INLINE_STREAM unstreamR #-}
+unstreamR s = runST $ unstreamRPrimM (Stream.liftStream s)
 
 {-# RULES
 
 "streamR/unstreamR [Vector]" forall s.
   streamR (new (New.unstreamR s)) = s
 
+"streamR/unstreamR [Vector_FLRC]" forall s.
+  streamR (unstreamR s) = s
+
 "New.unstreamR/streamR/new [Vector]" forall p.
   New.unstreamR (streamR (new p)) = p
 
@@ -1931,7 +2092,51 @@ unstreamM s = do
 
 unstreamPrimM :: (PrimMonad m, Vector v a) => MStream m a -> m (v a)
 {-# INLINE_STREAM unstreamPrimM #-}
-unstreamPrimM s = M.munstream s >>= unsafeFreeze
+unstreamPrimM s =
+  case MStream.size s of
+    Exact n  -> unstreamPrimMexact n s
+    Max n    -> unstreamPrimMmax n s
+    Unknown  -> unstreamPrimMunknown s
+
+unstreamPrimMexact :: (PrimMonad m, Vector v a) => Int -> MStream m a -> m (v a)
+{-# INLINE unstreamPrimMexact #-}
+unstreamPrimMexact n s = do
+  v <- INTERNAL_CHECK(checkLength) "unstreamPrimMexact" n
+       $ unsafeCreate n
+  let put i x = do
+                   INTERNAL_CHECK(checkIndex) "unstreamPrimMexact" i n
+                     $ unsafeInitElem v i x
+                   return (i+1)
+  n' <- MStream.foldM' put 0 s
+  v' <- basicUnsafeInited v
+  return $ INTERNAL_CHECK(checkSlice) "unstreamPrimMexact" 0 n' n
+         $ unsafeSlice 0 n v'
+
+unstreamPrimMmax :: (PrimMonad m, Vector v a) => Int -> MStream m a -> m (v a)
+{-# INLINE unstreamPrimMmax #-}
+unstreamPrimMmax n s = do
+  v <- INTERNAL_CHECK(checkLength) "unstreamPrimMmax" n
+       $ unsafeCreate n
+  let put i x = do
+                   INTERNAL_CHECK(checkIndex) "unstreamPrimMmax" i n
+                     $ unsafeInitElem v i x
+                   return (i+1)
+  n' <- MStream.foldM' put 0 s
+  v' <- basicUnsafeInited v
+  return $ INTERNAL_CHECK(checkSlice) "unstreamPrimMmax" 0 n' n
+         $ unsafeSlice 0 n' v'
+
+unstreamPrimMunknown :: (PrimMonad m, Vector v a) => MStream m a -> m (v a)
+{-# INLINE unstreamPrimMunknown #-}
+unstreamPrimMunknown s = do
+  v <- unsafeCreate 0
+  let put (v,i) x = do
+        v' <- unsafeAppend1 v i x
+        return (v',i+1)
+  (v',n) <- MStream.foldM put (v,0) s
+  v'' <- basicUnsafeInited v'
+  return $ INTERNAL_CHECK(checkSlice) "unstreamPrimMunknown" 0 n (length v'')
+         $ unsafeSlice 0 n v''
 
 -- FIXME: the next two functions are only necessary for the specialisations
 unstreamPrimM_IO :: Vector v a => MStream IO a -> IO (v a)
@@ -1949,6 +2154,116 @@ unstreamPrimM_ST = unstreamPrimM
 
  #-}
 
+unstreamRPrimM :: (PrimMonad m, Vector v a) => MStream m a -> m (v a)
+{-# INLINE_STREAM unstreamRPrimM #-}
+unstreamRPrimM s =
+  case upperBound (MStream.size s) of
+    Just n  -> unstreamRPrimMmax n s
+    Nothing -> unstreamRPrimMunknown s
+
+unstreamRPrimMmax :: (PrimMonad m, Vector v a) => Int -> MStream m a -> m (v a)
+{-# INLINE unstreamRPrimMmax #-}
+unstreamRPrimMmax n s = do
+  v <- INTERNAL_CHECK(checkLength) "unstreamRPrimMmax" n
+       $ unsafeCreate n
+  let put i x = do
+                   let i' = i-1
+                   INTERNAL_CHECK(checkIndex) "unstreamMmax" i' n
+                     $ unsafeInitElem v i' x
+                   return i'
+  i <- MStream.foldM' put n s
+  v' <- basicUnsafeInited v
+  return $ INTERNAL_CHECK(checkSlice) "unstreamRPrimMmax" i (n-i) n
+         $ unsafeSlice i (n-i) v'
+
+unstreamRPrimMunknown :: (PrimMonad m, Vector v a) => MStream m a -> m (v a)
+{-# INLINE unstreamRPrimMunknown #-}
+unstreamRPrimMunknown s = do
+  v <- unsafeCreate 0
+  let put (v,i) x = unsafePrepend1 v i x
+  (v',i) <- MStream.foldM put (v,0) s
+  v'' <- basicUnsafeInited v'
+  let n = length v''
+  return $ INTERNAL_CHECK(checkSlice) "unstreamRPrimMunknown" i (n-i) n
+         $ unsafeSlice i (n-i) v''
+
+-- Creation and initialisation utilities
+-- -------------------------------------
+
+-- | Create an uninitialised immutable vector of the given length. The length is not checked.
+unsafeCreate :: (PrimMonad m, Vector v a) => Int -> m (v a)
+{-# INLINE unsafeCreate #-}
+unsafeCreate n = UNSAFE_CHECK(checkLength) "unsafeCreate" n
+               $ basicUnsafeCreate n
+
+-- | Initialise the specified element.
+-- Contract: must be called at most once for any given element
+unsafeInitElem :: (PrimMonad m, Vector v a) => v a -> Int -> a -> m ()
+{-# INLINE unsafeInitElem #-}
+unsafeInitElem v i x = UNSAFE_CHECK(checkIndex) "unsafeInitElem" i (length v)
+                     $ basicUnsafeInitElem v i x
+
+-- | Append an element to the end of the vector, growing it if necessary.
+-- Contract: must be called at most once for any given element
+unsafeAppend1 :: (PrimMonad m, Vector v a) => v a -> Int -> a -> m (v a)
+{-# INLINE_INNER unsafeAppend1 #-}
+    -- NOTE: The case distinction has to be on the outside because
+    -- GHC creates a join point for the unsafeInitElem even when everything
+    -- is inlined. This is bad because with the join point, v isn't getting
+    -- unboxed.
+unsafeAppend1 v i x
+  | i < length v = do
+                     unsafeInitElem v i x
+                     return v
+  | otherwise    = do
+                     v' <- enlarge v
+                     INTERNAL_CHECK(checkIndex) "unsafeAppend1" i (length v')
+                       $ unsafeInitElem v' i x
+                     return v'
+
+unsafePrepend1 :: (PrimMonad m, Vector v a)
+        => v a -> Int -> a -> m (v a, Int)
+{-# INLINE_INNER unsafePrepend1 #-}
+unsafePrepend1 v i x
+  | i /= 0    = do
+                  let i' = i-1
+                  unsafeInitElem v i' x
+                  return (v, i')
+  | otherwise = do
+                  (v', i) <- enlargeFront v
+                  let i' = i-1
+                  INTERNAL_CHECK(checkIndex) "unsafePrepend1" i' (length v')
+                    $ unsafeInitElem v' i' x
+                  return (v', i')
+
+-- | Grow a vector logarithmically
+enlarge :: (PrimMonad m, Vector v a) => v a -> m (v a)
+{-# INLINE enlarge #-}
+enlarge v =
+  unsafeGrow v (max (length v) 1)
+
+enlargeFront :: (PrimMonad m, Vector v a) => v a -> m (v a, Int)
+{-# INLINE enlargeFront #-}
+enlargeFront v = do
+                   v' <- unsafeGrowFront v by
+                   return (v', by)
+  where
+    by = max (length v) 1
+
+unsafeGrow :: (PrimMonad m, Vector v a) => v a -> Int -> m (v a)
+{-# INLINE unsafeGrow #-}
+unsafeGrow v by =
+  UNSAFE_CHECK(checkLength) "enlarge" by
+    $ basicUnsafeGrow v by
+
+unsafeGrowFront :: (PrimMonad m, Vector v a) => v a -> Int -> m (v a)
+{-# INLINE unsafeGrowFront #-}
+unsafeGrowFront v by = UNSAFE_CHECK(checkLength) "unsafeGrowFront" by
+                     $ do
+                         let n = length v
+                         v' <- basicUnsafeCreate (by+n)
+                         basicUnsafeCopyI (basicUnsafeSlice by n v') v
+                         return v'
 
 -- Recycling support
 -- -----------------
@@ -1956,7 +2271,7 @@ unstreamPrimM_ST = unstreamPrimM
 -- | Construct a vector from a monadic initialiser.
 new :: Vector v a => New v a -> v a
 {-# INLINE_STREAM new #-}
-new m = m `seq` runST (unsafeFreeze =<< New.run m)
+new m = m `seq` runST (freeze =<< New.run m)
 
 -- | Convert a vector to an initialiser which, when run, produces a copy of
 -- the vector.
@@ -2024,4 +2339,3 @@ dataCast :: (Vector v a, Data a, Typeable1 v, Typeable1 t)
          => (forall d. Data  d => c (t d)) -> Maybe  (c (v a))
 {-# INLINE dataCast #-}
 dataCast f = gcast1 f
-
diff --git a/Data/Vector/Generic/Base.hs b/Data/Vector/Generic/Base.hs
index 7b6ece3..ac91d44 100644
--- a/Data/Vector/Generic/Base.hs
+++ b/Data/Vector/Generic/Base.hs
@@ -35,9 +35,9 @@ type family Mutable (v :: * -> *) :: * -> * -> *
 --
 -- Minimum complete implementation:
 --
---   * 'basicUnsafeFreeze'
+--   * 'basicUnsafeCreate'
 --
---   * 'basicUnsafeThaw'
+--   * 'basicUnsafeInitElem'
 --
 --   * 'basicLength'
 --
@@ -46,18 +46,18 @@ type family Mutable (v :: * -> *) :: * -> * -> *
 --   * 'basicUnsafeIndexM'
 --
 class MVector (Mutable v) a => Vector v a where
-  -- | /Assumed complexity: O(1)/
-  --
-  -- Unsafely convert a mutable vector to its immutable version
-  -- without copying. The mutable vector may not be used after
-  -- this operation.
-  basicUnsafeFreeze :: PrimMonad m => Mutable v (PrimState m) a -> m (v a)
+  -- Create an uninitialised immutable vector of the given length.
+  -- This method should not be called directly, use unsafeCreate instead.
+  basicUnsafeCreate :: PrimMonad m => Int -> m (v a)
 
-  -- | /Assumed complexity: O(1)/
-  --
-  -- Unsafely convert an immutable vector to its mutable version without
-  -- copying. The immutable vector may not be used after this operation.
-  basicUnsafeThaw :: PrimMonad m => v a -> m (Mutable v (PrimState m) a)
+  -- Initialise the specified element.
+  -- Contract: must be called at most once for any given element.
+  -- This method should not be called directly, use unsafeInit instead.
+  basicUnsafeInitElem :: PrimMonad m => v a -> Int -> a -> m ()
+
+  -- Set the array as initialised.
+  -- Contract: must be called at most once and only after all initialisation is done.
+  basicUnsafeInited :: PrimMonad m => v a -> m (v a)
 
   -- | /Assumed complexity: O(1)/
   --
@@ -99,6 +99,25 @@ class MVector (Mutable v) a => Vector v a where
   --
   basicUnsafeIndexM  :: Monad m => v a -> Int -> m a
 
+  -- | Grow a vector by the given number of elements. This method should not be
+  -- called directly, use 'unsafeGrow' instead.
+  basicUnsafeGrow :: (PrimMonad m, Vector v a) => v a -> Int -> m (v a)
+
+  {-# INLINE basicUnsafeGrow #-}
+  basicUnsafeGrow v by = do
+    let oldLen = basicLength v
+    let newLen = oldLen + by
+    v' <- basicUnsafeCreate newLen
+    let copy i
+          | i < oldLen = do
+                           x <- basicUnsafeIndexM v i
+                           basicUnsafeInitElem v' i x
+                           copy (i+1)
+          | otherwise  = return ()
+    copy 0
+    v'' <- basicUnsafeInited v'
+    return v''
+
   -- |  /Assumed complexity: O(n)/
   --
   -- Copy an immutable vector into a mutable one. The two vectors must have
@@ -107,7 +126,7 @@ class MVector (Mutable v) a => Vector v a where
   -- Instances of 'Vector' should redefine this method if they wish to support
   -- an efficient block copy operation.
   --
-  -- Default definition: copying basic on 'basicUnsafeIndexM' and
+  -- Default definition: copying based on 'basicUnsafeIndexM' and
   -- 'basicUnsafeWrite'.
   basicUnsafeCopy :: PrimMonad m => Mutable v (PrimState m) a -> v a -> m ()
 
@@ -115,13 +134,35 @@ class MVector (Mutable v) a => Vector v a where
   basicUnsafeCopy !dst !src = do_copy 0
     where
       !n = basicLength src
-
-      do_copy i | i < n = do
+      do_copy !i | i < n = do
                              x <- basicUnsafeIndexM src i
                              M.basicUnsafeWrite dst i x
                              do_copy (i+1)
                  | otherwise = return ()
 
+  -- |  /Assumed complexity: O(n)/
+  --
+  -- Copy an immutable vector into another immutable one. The two vectors must have
+  -- the same length but this is not checked, and the destination vector must be
+  -- uninitialised and will be initialised by the copy.
+  --
+  -- Instances of 'Vector' should redefine this method if they wish to support
+  -- an efficient block copy operation.
+  --
+  -- Default definition: copying based on 'basicUnsafeIndexM' and
+  -- 'basicUnsafeInitElem'.
+  basicUnsafeCopyI :: PrimMonad m => v a -> v a -> m ()
+
+  {-# INLINE basicUnsafeCopyI #-}
+  basicUnsafeCopyI !dst !src = do_copy 0
+    where
+      !n = basicLength src
+      do_copy !i | i < n = do
+                             x <- basicUnsafeIndexM src i
+                             basicUnsafeInitElem dst i x
+                             do_copy (i+1)
+                 | otherwise = return ()
+
   -- | Evaluate @a@ as far as storing it in a vector would and yield @b@.
   -- The @v a@ argument only fixes the type and is not touched. The method is
   -- only used for optimisation purposes. Thus, it is safe for instances of
diff --git a/Data/Vector/Primitive.hs b/Data/Vector/Primitive.hs
index 1fe3677..a357433 100644
--- a/Data/Vector/Primitive.hs
+++ b/Data/Vector/Primitive.hs
@@ -138,7 +138,9 @@ import qualified Data.Vector.Generic           as G
 import           Data.Vector.Primitive.Mutable ( MVector(..) )
 import qualified Data.Vector.Fusion.Stream as Stream
 import           Data.Primitive.ByteArray
+import           Data.Primitive.UnboxedArray
 import           Data.Primitive ( Prim, sizeOf )
+import           Data.Primitive.Types ( UnboxedArray )
 
 import Control.Monad ( liftM )
 import Control.Monad.ST ( ST )
@@ -169,7 +171,7 @@ import Data.Monoid   ( Monoid(..) )
 -- | Unboxed vectors of primitive types
 data Vector a = Vector {-# UNPACK #-} !Int
                        {-# UNPACK #-} !Int
-                       {-# UNPACK #-} !ByteArray
+                       {-# UNPACK #-} !(UnboxedArray a)
   deriving ( Typeable )
 
 instance (Show a, Prim a) => Show (Vector a) where
@@ -190,13 +192,14 @@ instance (Data a, Prim a) => Data (Vector a) where
 type instance G.Mutable Vector = MVector
 
 instance Prim a => G.Vector Vector a where
-  {-# INLINE basicUnsafeFreeze #-}
-  basicUnsafeFreeze (MVector i n marr)
-    = Vector i n `liftM` unsafeFreezeByteArray marr
+  {-# INLINE basicUnsafeCreate #-}
+  basicUnsafeCreate n = do {a <- newUnboxedArray n (undefined :: a); return $ Vector 0 n a}
 
-  {-# INLINE basicUnsafeThaw #-}
-  basicUnsafeThaw (Vector i n arr)
-    = MVector i n `liftM` unsafeThawByteArray arr
+  {-# INLINE basicUnsafeInitElem #-}
+  basicUnsafeInitElem (Vector j _ a) i x = initUnboxedArray a (i+j) x
+
+  {-# INLINE basicUnsafeInited #-}
+  basicUnsafeInited (Vector i n arr) = do {arr' <- unboxedArrayInited (undefined :: a) arr; return $ Vector i n arr'}
 
   {-# INLINE basicLength #-}
   basicLength (Vector _ n _) = n
@@ -205,13 +208,7 @@ instance Prim a => G.Vector Vector a where
   basicUnsafeSlice j n (Vector i _ arr) = Vector (i+j) n arr
 
   {-# INLINE basicUnsafeIndexM #-}
-  basicUnsafeIndexM (Vector i _ arr) j = return (indexByteArray arr (i+j))
-
-  {-# INLINE basicUnsafeCopy #-}
-  basicUnsafeCopy (MVector i n dst) (Vector j _ src)
-    = copyByteArray dst (i*sz) src (j*sz) (n*sz)
-    where
-      sz = sizeOf (undefined :: a)
+  basicUnsafeIndexM (Vector i _ arr) j = return (indexUnboxedArray arr (i+j))
 
   {-# INLINE elemseq #-}
   elemseq _ = seq
diff --git a/Data/Vector/Storable.hs b/Data/Vector/Storable.hs
index ebb68e1..9ac583b 100644
--- a/Data/Vector/Storable.hs
+++ b/Data/Vector/Storable.hs
@@ -146,6 +146,10 @@ import Foreign.ForeignPtr
 import Foreign.Ptr
 import Foreign.Marshal.Array ( advancePtr, copyArray )
 
+#if __GLASGOW_HASKELL__ >= 605
+import GHC.ForeignPtr (mallocPlainForeignPtrBytes)
+#endif
+
 import Control.Monad.ST ( ST )
 import Control.Monad.Primitive
 
@@ -195,11 +199,18 @@ instance (Data a, Storable a) => Data (Vector a) where
 type instance G.Mutable Vector = MVector
 
 instance Storable a => G.Vector Vector a where
-  {-# INLINE basicUnsafeFreeze #-}
-  basicUnsafeFreeze (MVector n fp) = return $ Vector n fp
+  {-# INLINE basicUnsafeCreate #-}
+  basicUnsafeCreate n =
+    unsafePrimToPrim $ do
+      fp <- mallocVector n
+      return $ Vector n fp
+
+  {-# INLINE basicUnsafeInitElem #-}
+  basicUnsafeInitElem (Vector _ fp) i x =
+    unsafePrimToPrim $ withForeignPtr fp $ \p -> pokeElemOff p i x
 
-  {-# INLINE basicUnsafeThaw #-}
-  basicUnsafeThaw (Vector n fp) = return $ MVector n fp
+  {-# INLINE basicUnsafeInited #-}
+  basicUnsafeInited v = return v
 
   {-# INLINE basicLength #-}
   basicLength (Vector n _) = n
@@ -223,6 +234,18 @@ instance Storable a => G.Vector Vector a where
   {-# INLINE elemseq #-}
   elemseq _ = seq
 
+{-# INLINE mallocVector #-}
+mallocVector :: Storable a => Int -> IO (ForeignPtr a)
+mallocVector =
+#if __GLASGOW_HASKELL__ >= 605
+    doMalloc undefined
+        where
+          doMalloc :: Storable b => b -> Int -> IO (ForeignPtr b)
+          doMalloc dummy size = mallocPlainForeignPtrBytes (size * sizeOf dummy)
+#else
+    mallocForeignPtrArray
+#endif
+
 -- See http://trac.haskell.org/vector/ticket/12
 instance (Storable a, Eq a) => Eq (Vector a) where
   {-# INLINE (==) #-}
diff --git a/Data/Vector/Strict.hs b/Data/Vector/Strict.hs
new file mode 100644
index 0000000..e23fcaa
--- /dev/null
+++ b/Data/Vector/Strict.hs
@@ -0,0 +1,1412 @@
+{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, TypeFamilies, Rank2Types #-}
+
+-- |
+-- Module      : Data.Vector.Strict
+-- Copyright   : (c) Roman Leshchinskiy 2008-2010
+-- License     : BSD-style
+--
+-- Maintainer  : Roman Leshchinskiy <rl@cse.unsw.edu.au>
+-- Stability   : experimental
+-- Portability : non-portable
+-- 
+-- A library for boxed vectors (that is, polymorphic arrays capable of
+-- holding any Haskell value). The vectors come in two flavors:
+--
+--  * mutable
+--
+--  * immutable
+--
+-- and support a rich interface of both list-like operations, and bulk
+-- array operations.
+--
+-- For unboxed arrays, use the 'Data.Vector.Unboxed' interface.
+--
+
+module Data.Vector.Strict (
+  -- * Boxed vectors
+  Vector, MVector,
+
+  -- * Accessors
+
+  -- ** Length information
+  length, null,
+
+  -- ** Indexing
+  (!), (!?), head, last,
+  unsafeIndex, unsafeHead, unsafeLast,
+
+  -- ** Monadic indexing
+  indexM, headM, lastM,
+  unsafeIndexM, unsafeHeadM, unsafeLastM,
+
+  -- ** Extracting subvectors (slicing)
+  slice, init, tail, take, drop, splitAt,
+  unsafeSlice, unsafeInit, unsafeTail, unsafeTake, unsafeDrop,
+
+  -- * Construction
+
+  -- ** Initialisation
+  empty, singleton, replicate, generate, iterateN,
+
+  -- ** Monadic initialisation
+  replicateM, generateM, create,
+
+  -- ** Unfolding
+  unfoldr, unfoldrN,
+
+  -- ** Enumeration
+  enumFromN, enumFromStepN, enumFromTo, enumFromThenTo,
+
+  -- ** Concatenation
+  cons, snoc, (++), concat,
+
+  -- ** Restricting memory usage
+  force,
+
+  -- * Modifying vectors
+
+  -- ** Bulk updates
+  (//), update, update_,
+  unsafeUpd, unsafeUpdate, unsafeUpdate_,
+
+  -- ** Accumulations
+  accum, accumulate, accumulate_,
+  unsafeAccum, unsafeAccumulate, unsafeAccumulate_,
+
+  -- ** Permutations 
+  reverse, backpermute, unsafeBackpermute,
+
+  -- ** Safe destructive updates
+  modify,
+
+  -- * Elementwise operations
+
+  -- ** Indexing
+  indexed,
+
+  -- ** Mapping
+  map, imap, concatMap,
+
+  -- ** Monadic mapping
+  mapM, mapM_, forM, forM_,
+
+  -- ** Zipping
+  zipWith, zipWith3, zipWith4, zipWith5, zipWith6,
+  izipWith, izipWith3, izipWith4, izipWith5, izipWith6,
+  zip, zip3, zip4, zip5, zip6,
+
+  -- ** Monadic zipping
+  zipWithM, zipWithM_,
+
+  -- ** Unzipping
+  unzip, unzip3, unzip4, unzip5, unzip6,
+
+  -- * Working with predicates
+
+  -- ** Filtering
+  filter, ifilter, filterM,
+  takeWhile, dropWhile,
+
+  -- ** Partitioning
+  partition, unstablePartition, span, break,
+
+  -- ** Searching
+  elem, notElem, find, findIndex, findIndices, elemIndex, elemIndices,
+
+  -- * Folding
+  foldl, foldl1, foldl', foldl1', foldr, foldr1, foldr', foldr1',
+  ifoldl, ifoldl', ifoldr, ifoldr',
+
+  -- ** Specialised folds
+  all, any, and, or,
+  sum, product,
+  maximum, maximumBy, minimum, minimumBy,
+  minIndex, minIndexBy, maxIndex, maxIndexBy,
+
+  -- ** Monadic folds
+  foldM, foldM', fold1M, fold1M',
+  foldM_, foldM'_, fold1M_, fold1M'_,
+
+  -- ** Monadic sequencing
+  sequence, sequence_,
+
+  -- * Prefix sums (scans)
+  prescanl, prescanl',
+  postscanl, postscanl',
+  scanl, scanl', scanl1, scanl1',
+  prescanr, prescanr',
+  postscanr, postscanr',
+  scanr, scanr', scanr1, scanr1',
+
+  -- * Conversions
+
+  -- ** Lists
+  toList, fromList, fromListN,
+
+  -- ** Other vector types
+  G.convert,
+
+  -- ** Mutable vectors
+  freeze, thaw, copy, unsafeFreeze, unsafeThaw, unsafeCopy
+) where
+
+import qualified Data.Vector.Generic as G
+import           Data.Vector.Mutable  ( MVector(..) )
+import           Data.Primitive.StrictImmutableArray
+import qualified Data.Vector.Fusion.Stream as Stream
+
+import Control.Monad ( liftM )
+import Control.Monad.ST ( ST )
+import Control.Monad.Primitive
+
+import Prelude hiding ( length, null,
+                        replicate, (++), concat,
+                        head, last,
+                        init, tail, take, drop, splitAt, reverse,
+                        map, concatMap,
+                        zipWith, zipWith3, zip, zip3, unzip, unzip3,
+                        filter, takeWhile, dropWhile, span, break,
+                        elem, notElem,
+                        foldl, foldl1, foldr, foldr1,
+                        all, any, and, or, sum, product, minimum, maximum,
+                        scanl, scanl1, scanr, scanr1,
+                        enumFromTo, enumFromThenTo,
+                        mapM, mapM_, sequence, sequence_ )
+
+import qualified Prelude
+
+import Data.Typeable ( Typeable )
+import Data.Data     ( Data(..) )
+
+import Data.Monoid   ( Monoid(..) )
+
+-- | Boxed vectors, supporting efficient slicing.
+data Vector a = Vector {-# UNPACK #-} !Int
+                       {-# UNPACK #-} !Int
+                       {-# UNPACK #-} !(StrictImmutableArray a)
+        deriving ( Typeable )
+
+instance Show a => Show (Vector a) where
+    show = (Prelude.++ " :: Data.Vector.Vector") . ("fromList " Prelude.++) . show . toList
+
+instance Data a => Data (Vector a) where
+  gfoldl       = G.gfoldl
+  toConstr _   = error "toConstr"
+  gunfold _ _  = error "gunfold"
+  dataTypeOf _ = G.mkType "Data.Vector.Vector"
+  dataCast1    = G.dataCast
+
+type instance G.Mutable Vector = MVector
+
+instance G.Vector Vector a where
+  {-# INLINE basicUnsafeCreate #-}
+  basicUnsafeCreate n = do {arr <- newStrictImmutableArray n; return $ Vector 0 n arr}
+
+  {-# INLINE basicUnsafeInitElem #-}
+  basicUnsafeInitElem (Vector j _ arr) i x = initStrictImmutableArray arr (i+j) x
+
+  {-# INLINE basicUnsafeInited #-}
+  basicUnsafeInited (Vector i n arr) = do {arr' <- strictImmutableArrayInited arr; return $ Vector i n arr'}
+
+  {-# INLINE basicLength #-}
+  basicLength (Vector _ n _) = n
+
+  {-# INLINE basicUnsafeSlice #-}
+  basicUnsafeSlice j n (Vector i _ arr) = Vector (i+j) n arr
+
+  {-# INLINE basicUnsafeIndexM #-}
+  basicUnsafeIndexM (Vector i _ arr) j = return $ indexStrictImmutableArray arr (i+j)
+
+-- See http://trac.haskell.org/vector/ticket/12
+instance Eq a => Eq (Vector a) where
+  {-# INLINE (==) #-}
+  xs == ys = Stream.eq (G.stream xs) (G.stream ys)
+
+  {-# INLINE (/=) #-}
+  xs /= ys = not (Stream.eq (G.stream xs) (G.stream ys))
+
+-- See http://trac.haskell.org/vector/ticket/12
+instance Ord a => Ord (Vector a) where
+  {-# INLINE compare #-}
+  compare xs ys = Stream.cmp (G.stream xs) (G.stream ys)
+
+  {-# INLINE (<) #-}
+  xs < ys = Stream.cmp (G.stream xs) (G.stream ys) == LT
+
+  {-# INLINE (<=) #-}
+  xs <= ys = Stream.cmp (G.stream xs) (G.stream ys) /= GT
+
+  {-# INLINE (>) #-}
+  xs > ys = Stream.cmp (G.stream xs) (G.stream ys) == GT
+
+  {-# INLINE (>=) #-}
+  xs >= ys = Stream.cmp (G.stream xs) (G.stream ys) /= LT
+
+instance Monoid (Vector a) where
+  {-# INLINE mempty #-}
+  mempty = empty
+
+  {-# INLINE mappend #-}
+  mappend = (++)
+
+  {-# INLINE mconcat #-}
+  mconcat = concat
+
+-- Length information
+-- ------------------
+
+-- | /O(1)/ Yield the length of the vector.
+length :: Vector a -> Int
+{-# INLINE length #-}
+length = G.length
+
+-- | /O(1)/ Test whether a vector if empty
+null :: Vector a -> Bool
+{-# INLINE null #-}
+null = G.null
+
+-- Indexing
+-- --------
+
+-- | O(1) Indexing
+(!) :: Vector a -> Int -> a
+{-# INLINE (!) #-}
+(!) = (G.!)
+
+-- | O(1) Safe indexing
+(!?) :: Vector a -> Int -> Maybe a
+{-# INLINE (!?) #-}
+(!?) = (G.!?)
+
+-- | /O(1)/ First element
+head :: Vector a -> a
+{-# INLINE head #-}
+head = G.head
+
+-- | /O(1)/ Last element
+last :: Vector a -> a
+{-# INLINE last #-}
+last = G.last
+
+-- | /O(1)/ Unsafe indexing without bounds checking
+unsafeIndex :: Vector a -> Int -> a
+{-# INLINE unsafeIndex #-}
+unsafeIndex = G.unsafeIndex
+
+-- | /O(1)/ First element without checking if the vector is empty
+unsafeHead :: Vector a -> a
+{-# INLINE unsafeHead #-}
+unsafeHead = G.unsafeHead
+
+-- | /O(1)/ Last element without checking if the vector is empty
+unsafeLast :: Vector a -> a
+{-# INLINE unsafeLast #-}
+unsafeLast = G.unsafeLast
+
+-- Monadic indexing
+-- ----------------
+
+-- | /O(1)/ Indexing in a monad.
+--
+-- The monad allows operations to be strict in the vector when necessary.
+-- Suppose vector copying is implemented like this:
+--
+-- > copy mv v = ... write mv i (v ! i) ...
+--
+-- For lazy vectors, @v ! i@ would not be evaluated which means that @mv@
+-- would unnecessarily retain a reference to @v@ in each element written.
+--
+-- With 'indexM', copying can be implemented like this instead:
+--
+-- > copy mv v = ... do
+-- >                   x <- indexM v i
+-- >                   write mv i x
+--
+-- Here, no references to @v@ are retained because indexing (but /not/ the
+-- elements) is evaluated eagerly.
+--
+indexM :: Monad m => Vector a -> Int -> m a
+{-# INLINE indexM #-}
+indexM = G.indexM
+
+-- | /O(1)/ First element of a vector in a monad. See 'indexM' for an
+-- explanation of why this is useful.
+headM :: Monad m => Vector a -> m a
+{-# INLINE headM #-}
+headM = G.headM
+
+-- | /O(1)/ Last element of a vector in a monad. See 'indexM' for an
+-- explanation of why this is useful.
+lastM :: Monad m => Vector a -> m a
+{-# INLINE lastM #-}
+lastM = G.lastM
+
+-- | /O(1)/ Indexing in a monad without bounds checks. See 'indexM' for an
+-- explanation of why this is useful.
+unsafeIndexM :: Monad m => Vector a -> Int -> m a
+{-# INLINE unsafeIndexM #-}
+unsafeIndexM = G.unsafeIndexM
+
+-- | /O(1)/ First element in a monad without checking for empty vectors.
+-- See 'indexM' for an explanation of why this is useful.
+unsafeHeadM :: Monad m => Vector a -> m a
+{-# INLINE unsafeHeadM #-}
+unsafeHeadM = G.unsafeHeadM
+
+-- | /O(1)/ Last element in a monad without checking for empty vectors.
+-- See 'indexM' for an explanation of why this is useful.
+unsafeLastM :: Monad m => Vector a -> m a
+{-# INLINE unsafeLastM #-}
+unsafeLastM = G.unsafeLastM
+
+-- Extracting subvectors (slicing)
+-- -------------------------------
+
+-- | /O(1)/ Yield a slice of the vector without copying it. The vector must
+-- contain at least @i+n@ elements.
+slice :: Int   -- ^ @i@ starting index
+                 -> Int   -- ^ @n@ length
+                 -> Vector a
+                 -> Vector a
+{-# INLINE slice #-}
+slice = G.slice
+
+-- | /O(1)/ Yield all but the last element without copying. The vector may not
+-- be empty.
+init :: Vector a -> Vector a
+{-# INLINE init #-}
+init = G.init
+
+-- | /O(1)/ Yield all but the first element without copying. The vector may not
+-- be empty.
+tail :: Vector a -> Vector a
+{-# INLINE tail #-}
+tail = G.tail
+
+-- | /O(1)/ Yield at the first @n@ elements without copying. The vector may
+-- contain less than @n@ elements in which case it is returned unchanged.
+take :: Int -> Vector a -> Vector a
+{-# INLINE take #-}
+take = G.take
+
+-- | /O(1)/ Yield all but the first @n@ elements without copying. The vector may
+-- contain less than @n@ elements in which case an empty vector is returned.
+drop :: Int -> Vector a -> Vector a
+{-# INLINE drop #-}
+drop = G.drop
+
+-- | /O(1)/ Yield the first @n@ elements paired with the remainder without copying.
+--
+-- Note that @'splitAt' n v@ is equivalent to @('take' n v, 'drop' n v)@
+-- but slightly more efficient.
+{-# INLINE splitAt #-}
+splitAt :: Int -> Vector a -> (Vector a, Vector a)
+splitAt = G.splitAt
+
+-- | /O(1)/ Yield a slice of the vector without copying. The vector must
+-- contain at least @i+n@ elements but this is not checked.
+unsafeSlice :: Int   -- ^ @i@ starting index
+                       -> Int   -- ^ @n@ length
+                       -> Vector a
+                       -> Vector a
+{-# INLINE unsafeSlice #-}
+unsafeSlice = G.unsafeSlice
+
+-- | /O(1)/ Yield all but the last element without copying. The vector may not
+-- be empty but this is not checked.
+unsafeInit :: Vector a -> Vector a
+{-# INLINE unsafeInit #-}
+unsafeInit = G.unsafeInit
+
+-- | /O(1)/ Yield all but the first element without copying. The vector may not
+-- be empty but this is not checked.
+unsafeTail :: Vector a -> Vector a
+{-# INLINE unsafeTail #-}
+unsafeTail = G.unsafeTail
+
+-- | /O(1)/ Yield the first @n@ elements without copying. The vector must
+-- contain at least @n@ elements but this is not checked.
+unsafeTake :: Int -> Vector a -> Vector a
+{-# INLINE unsafeTake #-}
+unsafeTake = G.unsafeTake
+
+-- | /O(1)/ Yield all but the first @n@ elements without copying. The vector
+-- must contain at least @n@ elements but this is not checked.
+unsafeDrop :: Int -> Vector a -> Vector a
+{-# INLINE unsafeDrop #-}
+unsafeDrop = G.unsafeDrop
+
+-- Initialisation
+-- --------------
+
+-- | /O(1)/ Empty vector
+empty :: Vector a
+{-# INLINE empty #-}
+empty = G.empty
+
+-- | /O(1)/ Vector with exactly one element
+singleton :: a -> Vector a
+{-# INLINE singleton #-}
+singleton = G.singleton
+
+-- | /O(n)/ Vector of the given length with the same value in each position
+replicate :: Int -> a -> Vector a
+{-# INLINE replicate #-}
+replicate = G.replicate
+
+-- | /O(n)/ Construct a vector of the given length by applying the function to
+-- each index
+generate :: Int -> (Int -> a) -> Vector a
+{-# INLINE generate #-}
+generate = G.generate
+
+-- | /O(n)/ Apply function n times to value. Zeroth element is original value.
+iterateN :: Int -> (a -> a) -> a -> Vector a
+{-# INLINE iterateN #-}
+iterateN = G.iterateN
+
+-- Unfolding
+-- ---------
+
+-- | /O(n)/ Construct a vector by repeatedly applying the generator function
+-- to a seed. The generator function yields 'Just' the next element and the
+-- new seed or 'Nothing' if there are no more elements.
+--
+-- > unfoldr (\n -> if n == 0 then Nothing else Just (n,n-1)) 10
+-- >  = <10,9,8,7,6,5,4,3,2,1>
+unfoldr :: (b -> Maybe (a, b)) -> b -> Vector a
+{-# INLINE unfoldr #-}
+unfoldr = G.unfoldr
+
+-- | /O(n)/ Construct a vector with at most @n@ by repeatedly applying the
+-- generator function to the a seed. The generator function yields 'Just' the
+-- next element and the new seed or 'Nothing' if there are no more elements.
+--
+-- > unfoldrN 3 (\n -> Just (n,n-1)) 10 = <10,9,8>
+unfoldrN :: Int -> (b -> Maybe (a, b)) -> b -> Vector a
+{-# INLINE unfoldrN #-}
+unfoldrN = G.unfoldrN
+
+-- Enumeration
+-- -----------
+
+-- | /O(n)/ Yield a vector of the given length containing the values @x@, @x+1@
+-- etc. This operation is usually more efficient than 'enumFromTo'.
+--
+-- > enumFromN 5 3 = <5,6,7>
+enumFromN :: Num a => a -> Int -> Vector a
+{-# INLINE enumFromN #-}
+enumFromN = G.enumFromN
+
+-- | /O(n)/ Yield a vector of the given length containing the values @x@, @x+y@,
+-- @x+y+y@ etc. This operations is usually more efficient than 'enumFromThenTo'.
+--
+-- > enumFromStepN 1 0.1 5 = <1,1.1,1.2,1.3,1.4>
+enumFromStepN :: Num a => a -> a -> Int -> Vector a
+{-# INLINE enumFromStepN #-}
+enumFromStepN = G.enumFromStepN
+
+-- | /O(n)/ Enumerate values from @x@ to @y@.
+--
+-- /WARNING:/ This operation can be very inefficient. If at all possible, use
+-- 'enumFromN' instead.
+enumFromTo :: Enum a => a -> a -> Vector a
+{-# INLINE enumFromTo #-}
+enumFromTo = G.enumFromTo
+
+-- | /O(n)/ Enumerate values from @x@ to @y@ with a specific step @z@.
+--
+-- /WARNING:/ This operation can be very inefficient. If at all possible, use
+-- 'enumFromStepN' instead.
+enumFromThenTo :: Enum a => a -> a -> a -> Vector a
+{-# INLINE enumFromThenTo #-}
+enumFromThenTo = G.enumFromThenTo
+
+-- Concatenation
+-- -------------
+
+-- | /O(n)/ Prepend an element
+cons :: a -> Vector a -> Vector a
+{-# INLINE cons #-}
+cons = G.cons
+
+-- | /O(n)/ Append an element
+snoc :: Vector a -> a -> Vector a
+{-# INLINE snoc #-}
+snoc = G.snoc
+
+infixr 5 ++
+-- | /O(m+n)/ Concatenate two vectors
+(++) :: Vector a -> Vector a -> Vector a
+{-# INLINE (++) #-}
+(++) = (G.++)
+
+-- | /O(n)/ Concatenate all vectors in the list
+concat :: [Vector a] -> Vector a
+{-# INLINE concat #-}
+concat = G.concat
+
+-- Monadic initialisation
+-- ----------------------
+
+-- | /O(n)/ Execute the monadic action the given number of times and store the
+-- results in a vector.
+replicateM :: Monad m => Int -> m a -> m (Vector a)
+{-# INLINE replicateM #-}
+replicateM = G.replicateM
+
+-- | /O(n)/ Construct a vector of the given length by applying the monadic
+-- action to each index
+generateM :: Monad m => Int -> (Int -> m a) -> m (Vector a)
+{-# INLINE generateM #-}
+generateM = G.generateM
+
+-- | Execute the monadic action and freeze the resulting vector.
+--
+-- @
+-- create (do { v \<- new 2; write v 0 \'a\'; write v 1 \'b\' }) = \<'a','b'\>
+-- @
+create :: (forall s. ST s (MVector s a)) -> Vector a
+{-# INLINE create #-}
+-- NOTE: eta-expanded due to http://hackage.haskell.org/trac/ghc/ticket/4120
+create p = G.create p
+
+
+
+-- Restricting memory usage
+-- ------------------------
+
+-- | /O(n)/ Yield the argument but force it not to retain any extra memory,
+-- possibly by copying it.
+--
+-- This is especially useful when dealing with slices. For example:
+--
+-- > force (slice 0 2 <huge vector>)
+--
+-- Here, the slice retains a reference to the huge vector. Forcing it creates
+-- a copy of just the elements that belong to the slice and allows the huge
+-- vector to be garbage collected.
+force :: Vector a -> Vector a
+{-# INLINE force #-}
+force = G.force
+
+-- Bulk updates
+-- ------------
+
+-- | /O(m+n)/ For each pair @(i,a)@ from the list, replace the vector
+-- element at position @i@ by @a@.
+--
+-- > <5,9,2,7> // [(2,1),(0,3),(2,8)] = <3,9,8,7>
+--
+(//) :: Vector a   -- ^ initial vector (of length @m@)
+                -> [(Int, a)] -- ^ list of index/value pairs (of length @n@) 
+                -> Vector a
+{-# INLINE (//) #-}
+(//) = (G.//)
+
+-- | /O(m+n)/ For each pair @(i,a)@ from the vector of index/value pairs,
+-- replace the vector element at position @i@ by @a@.
+--
+-- > update <5,9,2,7> <(2,1),(0,3),(2,8)> = <3,9,8,7>
+--
+update :: Vector a        -- ^ initial vector (of length @m@)
+       -> Vector (Int, a) -- ^ vector of index/value pairs (of length @n@)
+       -> Vector a
+{-# INLINE update #-}
+update = G.update
+
+-- | /O(m+min(n1,n2))/ For each index @i@ from the index vector and the
+-- corresponding value @a@ from the value vector, replace the element of the
+-- initial vector at position @i@ by @a@.
+--
+-- > update_ <5,9,2,7>  <2,0,2> <1,3,8> = <3,9,8,7>
+--
+-- The function 'update' provides the same functionality and is usually more
+-- convenient.
+--
+-- @
+-- update_ xs is ys = 'update' xs ('zip' is ys)
+-- @
+update_ :: Vector a   -- ^ initial vector (of length @m@)
+        -> Vector Int -- ^ index vector (of length @n1@)
+        -> Vector a   -- ^ value vector (of length @n2@)
+        -> Vector a
+{-# INLINE update_ #-}
+update_ = G.update_
+
+-- | Same as ('//') but without bounds checking.
+unsafeUpd :: Vector a -> [(Int, a)] -> Vector a
+{-# INLINE unsafeUpd #-}
+unsafeUpd = G.unsafeUpd
+
+-- | Same as 'update' but without bounds checking.
+unsafeUpdate :: Vector a -> Vector (Int, a) -> Vector a
+{-# INLINE unsafeUpdate #-}
+unsafeUpdate = G.unsafeUpdate
+
+-- | Same as 'update_' but without bounds checking.
+unsafeUpdate_ :: Vector a -> Vector Int -> Vector a -> Vector a
+{-# INLINE unsafeUpdate_ #-}
+unsafeUpdate_ = G.unsafeUpdate_
+
+-- Accumulations
+-- -------------
+
+-- | /O(m+n)/ For each pair @(i,b)@ from the list, replace the vector element
+-- @a@ at position @i@ by @f a b@.
+--
+-- > accum (+) <5,9,2> [(2,4),(1,6),(0,3),(1,7)] = <5+3, 9+6+7, 2+4>
+accum :: (a -> b -> a) -- ^ accumulating function @f@
+      -> Vector a      -- ^ initial vector (of length @m@)
+      -> [(Int,b)]     -- ^ list of index/value pairs (of length @n@)
+      -> Vector a
+{-# INLINE accum #-}
+accum = G.accum
+
+-- | /O(m+n)/ For each pair @(i,b)@ from the vector of pairs, replace the vector
+-- element @a@ at position @i@ by @f a b@.
+--
+-- > accumulate (+) <5,9,2> <(2,4),(1,6),(0,3),(1,7)> = <5+3, 9+6+7, 2+4>
+accumulate :: (a -> b -> a)  -- ^ accumulating function @f@
+            -> Vector a       -- ^ initial vector (of length @m@)
+            -> Vector (Int,b) -- ^ vector of index/value pairs (of length @n@)
+            -> Vector a
+{-# INLINE accumulate #-}
+accumulate = G.accumulate
+
+-- | /O(m+min(n1,n2))/ For each index @i@ from the index vector and the
+-- corresponding value @b@ from the the value vector,
+-- replace the element of the initial vector at
+-- position @i@ by @f a b@.
+--
+-- > accumulate_ (+) <5,9,2> <2,1,0,1> <4,6,3,7> = <5+3, 9+6+7, 2+4>
+--
+-- The function 'accumulate' provides the same functionality and is usually more
+-- convenient.
+--
+-- @
+-- accumulate_ f as is bs = 'accumulate' f as ('zip' is bs)
+-- @
+accumulate_ :: (a -> b -> a) -- ^ accumulating function @f@
+            -> Vector a      -- ^ initial vector (of length @m@)
+            -> Vector Int    -- ^ index vector (of length @n1@)
+            -> Vector b      -- ^ value vector (of length @n2@)
+            -> Vector a
+{-# INLINE accumulate_ #-}
+accumulate_ = G.accumulate_
+
+-- | Same as 'accum' but without bounds checking.
+unsafeAccum :: (a -> b -> a) -> Vector a -> [(Int,b)] -> Vector a
+{-# INLINE unsafeAccum #-}
+unsafeAccum = G.unsafeAccum
+
+-- | Same as 'accumulate' but without bounds checking.
+unsafeAccumulate :: (a -> b -> a) -> Vector a -> Vector (Int,b) -> Vector a
+{-# INLINE unsafeAccumulate #-}
+unsafeAccumulate = G.unsafeAccumulate
+
+-- | Same as 'accumulate_' but without bounds checking.
+unsafeAccumulate_
+  :: (a -> b -> a) -> Vector a -> Vector Int -> Vector b -> Vector a
+{-# INLINE unsafeAccumulate_ #-}
+unsafeAccumulate_ = G.unsafeAccumulate_
+
+-- Permutations
+-- ------------
+
+-- | /O(n)/ Reverse a vector
+reverse :: Vector a -> Vector a
+{-# INLINE reverse #-}
+reverse = G.reverse
+
+-- | /O(n)/ Yield the vector obtained by replacing each element @i@ of the
+-- index vector by @xs'!'i@. This is equivalent to @'map' (xs'!') is@ but is
+-- often much more efficient.
+--
+-- > backpermute <a,b,c,d> <0,3,2,3,1,0> = <a,d,c,d,b,a>
+backpermute :: Vector a -> Vector Int -> Vector a
+{-# INLINE backpermute #-}
+backpermute = G.backpermute
+
+-- | Same as 'backpermute' but without bounds checking.
+unsafeBackpermute :: Vector a -> Vector Int -> Vector a
+{-# INLINE unsafeBackpermute #-}
+unsafeBackpermute = G.unsafeBackpermute
+
+-- Safe destructive updates
+-- ------------------------
+
+-- | Apply a destructive operation to a vector. The operation will be
+-- performed in place if it is safe to do so and will modify a copy of the
+-- vector otherwise.
+--
+-- @
+-- modify (\\v -> write v 0 \'x\') ('replicate' 3 \'a\') = \<\'x\',\'a\',\'a\'\>
+-- @
+modify :: (forall s. MVector s a -> ST s ()) -> Vector a -> Vector a
+{-# INLINE modify #-}
+modify p = G.modify p
+
+-- Indexing
+-- --------
+
+-- | /O(n)/ Pair each element in a vector with its index
+indexed :: Vector a -> Vector (Int,a)
+{-# INLINE indexed #-}
+indexed = G.indexed
+
+-- Mapping
+-- -------
+
+-- | /O(n)/ Map a function over a vector
+map :: (a -> b) -> Vector a -> Vector b
+{-# INLINE map #-}
+map = G.map
+
+-- | /O(n)/ Apply a function to every element of a vector and its index
+imap :: (Int -> a -> b) -> Vector a -> Vector b
+{-# INLINE imap #-}
+imap = G.imap
+
+-- | Map a function over a vector and concatenate the results.
+concatMap :: (a -> Vector b) -> Vector a -> Vector b
+{-# INLINE concatMap #-}
+concatMap = G.concatMap
+
+-- Monadic mapping
+-- ---------------
+
+-- | /O(n)/ Apply the monadic action to all elements of the vector, yielding a
+-- vector of results
+mapM :: Monad m => (a -> m b) -> Vector a -> m (Vector b)
+{-# INLINE mapM #-}
+mapM = G.mapM
+
+-- | /O(n)/ Apply the monadic action to all elements of a vector and ignore the
+-- results
+mapM_ :: Monad m => (a -> m b) -> Vector a -> m ()
+{-# INLINE mapM_ #-}
+mapM_ = G.mapM_
+
+-- | /O(n)/ Apply the monadic action to all elements of the vector, yielding a
+-- vector of results. Equvalent to @flip 'mapM'@.
+forM :: Monad m => Vector a -> (a -> m b) -> m (Vector b)
+{-# INLINE forM #-}
+forM = G.forM
+
+-- | /O(n)/ Apply the monadic action to all elements of a vector and ignore the
+-- results. Equivalent to @flip 'mapM_'@.
+forM_ :: Monad m => Vector a -> (a -> m b) -> m ()
+{-# INLINE forM_ #-}
+forM_ = G.forM_
+
+-- Zipping
+-- -------
+
+-- | /O(min(m,n))/ Zip two vectors with the given function.
+zipWith :: (a -> b -> c) -> Vector a -> Vector b -> Vector c
+{-# INLINE zipWith #-}
+zipWith = G.zipWith
+
+-- | Zip three vectors with the given function.
+zipWith3 :: (a -> b -> c -> d) -> Vector a -> Vector b -> Vector c -> Vector d
+{-# INLINE zipWith3 #-}
+zipWith3 = G.zipWith3
+
+zipWith4 :: (a -> b -> c -> d -> e)
+         -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
+{-# INLINE zipWith4 #-}
+zipWith4 = G.zipWith4
+
+zipWith5 :: (a -> b -> c -> d -> e -> f)
+         -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
+         -> Vector f
+{-# INLINE zipWith5 #-}
+zipWith5 = G.zipWith5
+
+zipWith6 :: (a -> b -> c -> d -> e -> f -> g)
+         -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
+         -> Vector f -> Vector g
+{-# INLINE zipWith6 #-}
+zipWith6 = G.zipWith6
+
+-- | /O(min(m,n))/ Zip two vectors with a function that also takes the
+-- elements' indices.
+izipWith :: (Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c
+{-# INLINE izipWith #-}
+izipWith = G.izipWith
+
+-- | Zip three vectors and their indices with the given function.
+izipWith3 :: (Int -> a -> b -> c -> d)
+          -> Vector a -> Vector b -> Vector c -> Vector d
+{-# INLINE izipWith3 #-}
+izipWith3 = G.izipWith3
+
+izipWith4 :: (Int -> a -> b -> c -> d -> e)
+          -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
+{-# INLINE izipWith4 #-}
+izipWith4 = G.izipWith4
+
+izipWith5 :: (Int -> a -> b -> c -> d -> e -> f)
+          -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
+          -> Vector f
+{-# INLINE izipWith5 #-}
+izipWith5 = G.izipWith5
+
+izipWith6 :: (Int -> a -> b -> c -> d -> e -> f -> g)
+          -> Vector a -> Vector b -> Vector c -> Vector d -> Vector e
+          -> Vector f -> Vector g
+{-# INLINE izipWith6 #-}
+izipWith6 = G.izipWith6
+
+-- | Elementwise pairing of array elements. 
+zip :: Vector a -> Vector b -> Vector (a, b)
+{-# INLINE zip #-}
+zip = G.zip
+
+-- | zip together three vectors into a vector of triples
+zip3 :: Vector a -> Vector b -> Vector c -> Vector (a, b, c)
+{-# INLINE zip3 #-}
+zip3 = G.zip3
+
+zip4 :: Vector a -> Vector b -> Vector c -> Vector d
+     -> Vector (a, b, c, d)
+{-# INLINE zip4 #-}
+zip4 = G.zip4
+
+zip5 :: Vector a -> Vector b -> Vector c -> Vector d -> Vector e
+     -> Vector (a, b, c, d, e)
+{-# INLINE zip5 #-}
+zip5 = G.zip5
+
+zip6 :: Vector a -> Vector b -> Vector c -> Vector d -> Vector e -> Vector f
+     -> Vector (a, b, c, d, e, f)
+{-# INLINE zip6 #-}
+zip6 = G.zip6
+
+-- Unzipping
+-- ---------
+
+-- | /O(min(m,n))/ Unzip a vector of pairs.
+unzip :: Vector (a, b) -> (Vector a, Vector b)
+{-# INLINE unzip #-}
+unzip = G.unzip
+
+unzip3 :: Vector (a, b, c) -> (Vector a, Vector b, Vector c)
+{-# INLINE unzip3 #-}
+unzip3 = G.unzip3
+
+unzip4 :: Vector (a, b, c, d) -> (Vector a, Vector b, Vector c, Vector d)
+{-# INLINE unzip4 #-}
+unzip4 = G.unzip4
+
+unzip5 :: Vector (a, b, c, d, e)
+       -> (Vector a, Vector b, Vector c, Vector d, Vector e)
+{-# INLINE unzip5 #-}
+unzip5 = G.unzip5
+
+unzip6 :: Vector (a, b, c, d, e, f)
+       -> (Vector a, Vector b, Vector c, Vector d, Vector e, Vector f)
+{-# INLINE unzip6 #-}
+unzip6 = G.unzip6
+
+-- Monadic zipping
+-- ---------------
+
+-- | /O(min(m,n))/ Zip the two vectors with the monadic action and yield a
+-- vector of results
+zipWithM :: Monad m => (a -> b -> m c) -> Vector a -> Vector b -> m (Vector c)
+{-# INLINE zipWithM #-}
+zipWithM = G.zipWithM
+
+-- | /O(min(m,n))/ Zip the two vectors with the monadic action and ignore the
+-- results
+zipWithM_ :: Monad m => (a -> b -> m c) -> Vector a -> Vector b -> m ()
+{-# INLINE zipWithM_ #-}
+zipWithM_ = G.zipWithM_
+
+-- Filtering
+-- ---------
+
+-- | /O(n)/ Drop elements that do not satisfy the predicate
+filter :: (a -> Bool) -> Vector a -> Vector a
+{-# INLINE filter #-}
+filter = G.filter
+
+-- | /O(n)/ Drop elements that do not satisfy the predicate which is applied to
+-- values and their indices
+ifilter :: (Int -> a -> Bool) -> Vector a -> Vector a
+{-# INLINE ifilter #-}
+ifilter = G.ifilter
+
+-- | /O(n)/ Drop elements that do not satisfy the monadic predicate
+filterM :: Monad m => (a -> m Bool) -> Vector a -> m (Vector a)
+{-# INLINE filterM #-}
+filterM = G.filterM
+
+-- | /O(n)/ Yield the longest prefix of elements satisfying the predicate
+-- without copying.
+takeWhile :: (a -> Bool) -> Vector a -> Vector a
+{-# INLINE takeWhile #-}
+takeWhile = G.takeWhile
+
+-- | /O(n)/ Drop the longest prefix of elements that satisfy the predicate
+-- without copying.
+dropWhile :: (a -> Bool) -> Vector a -> Vector a
+{-# INLINE dropWhile #-}
+dropWhile = G.dropWhile
+
+-- Parititioning
+-- -------------
+
+-- | /O(n)/ Split the vector in two parts, the first one containing those
+-- elements that satisfy the predicate and the second one those that don't. The
+-- relative order of the elements is preserved at the cost of a sometimes
+-- reduced performance compared to 'unstablePartition'.
+partition :: (a -> Bool) -> Vector a -> (Vector a, Vector a)
+{-# INLINE partition #-}
+partition = G.partition
+
+-- | /O(n)/ Split the vector in two parts, the first one containing those
+-- elements that satisfy the predicate and the second one those that don't.
+-- The order of the elements is not preserved but the operation is often
+-- faster than 'partition'.
+unstablePartition :: (a -> Bool) -> Vector a -> (Vector a, Vector a)
+{-# INLINE unstablePartition #-}
+unstablePartition = G.unstablePartition
+
+-- | /O(n)/ Split the vector into the longest prefix of elements that satisfy
+-- the predicate and the rest without copying.
+span :: (a -> Bool) -> Vector a -> (Vector a, Vector a)
+{-# INLINE span #-}
+span = G.span
+
+-- | /O(n)/ Split the vector into the longest prefix of elements that do not
+-- satisfy the predicate and the rest without copying.
+break :: (a -> Bool) -> Vector a -> (Vector a, Vector a)
+{-# INLINE break #-}
+break = G.break
+
+-- Searching
+-- ---------
+
+infix 4 `elem`
+-- | /O(n)/ Check if the vector contains an element
+elem :: Eq a => a -> Vector a -> Bool
+{-# INLINE elem #-}
+elem = G.elem
+
+infix 4 `notElem`
+-- | /O(n)/ Check if the vector does not contain an element (inverse of 'elem')
+notElem :: Eq a => a -> Vector a -> Bool
+{-# INLINE notElem #-}
+notElem = G.notElem
+
+-- | /O(n)/ Yield 'Just' the first element matching the predicate or 'Nothing'
+-- if no such element exists.
+find :: (a -> Bool) -> Vector a -> Maybe a
+{-# INLINE find #-}
+find = G.find
+
+-- | /O(n)/ Yield 'Just' the index of the first element matching the predicate
+-- or 'Nothing' if no such element exists.
+findIndex :: (a -> Bool) -> Vector a -> Maybe Int
+{-# INLINE findIndex #-}
+findIndex = G.findIndex
+
+-- | /O(n)/ Yield the indices of elements satisfying the predicate in ascending
+-- order.
+findIndices :: (a -> Bool) -> Vector a -> Vector Int
+{-# INLINE findIndices #-}
+findIndices = G.findIndices
+
+-- | /O(n)/ Yield 'Just' the index of the first occurence of the given element or
+-- 'Nothing' if the vector does not contain the element. This is a specialised
+-- version of 'findIndex'.
+elemIndex :: Eq a => a -> Vector a -> Maybe Int
+{-# INLINE elemIndex #-}
+elemIndex = G.elemIndex
+
+-- | /O(n)/ Yield the indices of all occurences of the given element in
+-- ascending order. This is a specialised version of 'findIndices'.
+elemIndices :: Eq a => a -> Vector a -> Vector Int
+{-# INLINE elemIndices #-}
+elemIndices = G.elemIndices
+
+-- Folding
+-- -------
+
+-- | /O(n)/ Left fold
+foldl :: (a -> b -> a) -> a -> Vector b -> a
+{-# INLINE foldl #-}
+foldl = G.foldl
+
+-- | /O(n)/ Left fold on non-empty vectors
+foldl1 :: (a -> a -> a) -> Vector a -> a
+{-# INLINE foldl1 #-}
+foldl1 = G.foldl1
+
+-- | /O(n)/ Left fold with strict accumulator
+foldl' :: (a -> b -> a) -> a -> Vector b -> a
+{-# INLINE foldl' #-}
+foldl' = G.foldl'
+
+-- | /O(n)/ Left fold on non-empty vectors with strict accumulator
+foldl1' :: (a -> a -> a) -> Vector a -> a
+{-# INLINE foldl1' #-}
+foldl1' = G.foldl1'
+
+-- | /O(n)/ Right fold
+foldr :: (a -> b -> b) -> b -> Vector a -> b
+{-# INLINE foldr #-}
+foldr = G.foldr
+
+-- | /O(n)/ Right fold on non-empty vectors
+foldr1 :: (a -> a -> a) -> Vector a -> a
+{-# INLINE foldr1 #-}
+foldr1 = G.foldr1
+
+-- | /O(n)/ Right fold with a strict accumulator
+foldr' :: (a -> b -> b) -> b -> Vector a -> b
+{-# INLINE foldr' #-}
+foldr' = G.foldr'
+
+-- | /O(n)/ Right fold on non-empty vectors with strict accumulator
+foldr1' :: (a -> a -> a) -> Vector a -> a
+{-# INLINE foldr1' #-}
+foldr1' = G.foldr1'
+
+-- | /O(n)/ Left fold (function applied to each element and its index)
+ifoldl :: (a -> Int -> b -> a) -> a -> Vector b -> a
+{-# INLINE ifoldl #-}
+ifoldl = G.ifoldl
+
+-- | /O(n)/ Left fold with strict accumulator (function applied to each element
+-- and its index)
+ifoldl' :: (a -> Int -> b -> a) -> a -> Vector b -> a
+{-# INLINE ifoldl' #-}
+ifoldl' = G.ifoldl'
+
+-- | /O(n)/ Right fold (function applied to each element and its index)
+ifoldr :: (Int -> a -> b -> b) -> b -> Vector a -> b
+{-# INLINE ifoldr #-}
+ifoldr = G.ifoldr
+
+-- | /O(n)/ Right fold with strict accumulator (function applied to each
+-- element and its index)
+ifoldr' :: (Int -> a -> b -> b) -> b -> Vector a -> b
+{-# INLINE ifoldr' #-}
+ifoldr' = G.ifoldr'
+
+-- Specialised folds
+-- -----------------
+
+-- | /O(n)/ Check if all elements satisfy the predicate.
+all :: (a -> Bool) -> Vector a -> Bool
+{-# INLINE all #-}
+all = G.all
+
+-- | /O(n)/ Check if any element satisfies the predicate.
+any :: (a -> Bool) -> Vector a -> Bool
+{-# INLINE any #-}
+any = G.any
+
+-- | /O(n)/ Check if all elements are 'True'
+and :: Vector Bool -> Bool
+{-# INLINE and #-}
+and = G.and
+
+-- | /O(n)/ Check if any element is 'True'
+or :: Vector Bool -> Bool
+{-# INLINE or #-}
+or = G.or
+
+-- | /O(n)/ Compute the sum of the elements
+sum :: Num a => Vector a -> a
+{-# INLINE sum #-}
+sum = G.sum
+
+-- | /O(n)/ Compute the produce of the elements
+product :: Num a => Vector a -> a
+{-# INLINE product #-}
+product = G.product
+
+-- | /O(n)/ Yield the maximum element of the vector. The vector may not be
+-- empty.
+maximum :: Ord a => Vector a -> a
+{-# INLINE maximum #-}
+maximum = G.maximum
+
+-- | /O(n)/ Yield the maximum element of the vector according to the given
+-- comparison function. The vector may not be empty.
+maximumBy :: (a -> a -> Ordering) -> Vector a -> a
+{-# INLINE maximumBy #-}
+maximumBy = G.maximumBy
+
+-- | /O(n)/ Yield the minimum element of the vector. The vector may not be
+-- empty.
+minimum :: Ord a => Vector a -> a
+{-# INLINE minimum #-}
+minimum = G.minimum
+
+-- | /O(n)/ Yield the minimum element of the vector according to the given
+-- comparison function. The vector may not be empty.
+minimumBy :: (a -> a -> Ordering) -> Vector a -> a
+{-# INLINE minimumBy #-}
+minimumBy = G.minimumBy
+
+-- | /O(n)/ Yield the index of the maximum element of the vector. The vector
+-- may not be empty.
+maxIndex :: Ord a => Vector a -> Int
+{-# INLINE maxIndex #-}
+maxIndex = G.maxIndex
+
+-- | /O(n)/ Yield the index of the maximum element of the vector according to
+-- the given comparison function. The vector may not be empty.
+maxIndexBy :: (a -> a -> Ordering) -> Vector a -> Int
+{-# INLINE maxIndexBy #-}
+maxIndexBy = G.maxIndexBy
+
+-- | /O(n)/ Yield the index of the minimum element of the vector. The vector
+-- may not be empty.
+minIndex :: Ord a => Vector a -> Int
+{-# INLINE minIndex #-}
+minIndex = G.minIndex
+
+-- | /O(n)/ Yield the index of the minimum element of the vector according to
+-- the given comparison function. The vector may not be empty.
+minIndexBy :: (a -> a -> Ordering) -> Vector a -> Int
+{-# INLINE minIndexBy #-}
+minIndexBy = G.minIndexBy
+
+-- Monadic folds
+-- -------------
+
+-- | /O(n)/ Monadic fold
+foldM :: Monad m => (a -> b -> m a) -> a -> Vector b -> m a
+{-# INLINE foldM #-}
+foldM = G.foldM
+
+-- | /O(n)/ Monadic fold over non-empty vectors
+fold1M :: Monad m => (a -> a -> m a) -> Vector a -> m a
+{-# INLINE fold1M #-}
+fold1M = G.fold1M
+
+-- | /O(n)/ Monadic fold with strict accumulator
+foldM' :: Monad m => (a -> b -> m a) -> a -> Vector b -> m a
+{-# INLINE foldM' #-}
+foldM' = G.foldM'
+
+-- | /O(n)/ Monadic fold over non-empty vectors with strict accumulator
+fold1M' :: Monad m => (a -> a -> m a) -> Vector a -> m a
+{-# INLINE fold1M' #-}
+fold1M' = G.fold1M'
+
+-- | /O(n)/ Monadic fold that discards the result
+foldM_ :: Monad m => (a -> b -> m a) -> a -> Vector b -> m ()
+{-# INLINE foldM_ #-}
+foldM_ = G.foldM_
+
+-- | /O(n)/ Monadic fold over non-empty vectors that discards the result
+fold1M_ :: Monad m => (a -> a -> m a) -> Vector a -> m ()
+{-# INLINE fold1M_ #-}
+fold1M_ = G.fold1M_
+
+-- | /O(n)/ Monadic fold with strict accumulator that discards the result
+foldM'_ :: Monad m => (a -> b -> m a) -> a -> Vector b -> m ()
+{-# INLINE foldM'_ #-}
+foldM'_ = G.foldM'_
+
+-- | /O(n)/ Monadic fold over non-empty vectors with strict accumulator
+-- that discards the result
+fold1M'_ :: Monad m => (a -> a -> m a) -> Vector a -> m ()
+{-# INLINE fold1M'_ #-}
+fold1M'_ = G.fold1M'_
+
+-- Monadic sequencing
+-- ------------------
+
+-- | Evaluate each action and collect the results
+sequence :: Monad m => Vector (m a) -> m (Vector a)
+{-# INLINE sequence #-}
+sequence = G.sequence
+
+-- | Evaluate each action and discard the results
+sequence_ :: Monad m => Vector (m a) -> m ()
+{-# INLINE sequence_ #-}
+sequence_ = G.sequence_
+
+-- Prefix sums (scans)
+-- -------------------
+
+-- | /O(n)/ Prescan
+--
+-- @
+-- prescanl f z = 'init' . 'scanl' f z
+-- @
+--
+-- Example: @prescanl (+) 0 \<1,2,3,4\> = \<0,1,3,6\>@
+--
+prescanl :: (a -> b -> a) -> a -> Vector b -> Vector a
+{-# INLINE prescanl #-}
+prescanl = G.prescanl
+
+-- | /O(n)/ Prescan with strict accumulator
+prescanl' :: (a -> b -> a) -> a -> Vector b -> Vector a
+{-# INLINE prescanl' #-}
+prescanl' = G.prescanl'
+
+-- | /O(n)/ Scan
+--
+-- @
+-- postscanl f z = 'tail' . 'scanl' f z
+-- @
+--
+-- Example: @postscanl (+) 0 \<1,2,3,4\> = \<1,3,6,10\>@
+--
+postscanl :: (a -> b -> a) -> a -> Vector b -> Vector a
+{-# INLINE postscanl #-}
+postscanl = G.postscanl
+
+-- | /O(n)/ Scan with strict accumulator
+postscanl' :: (a -> b -> a) -> a -> Vector b -> Vector a
+{-# INLINE postscanl' #-}
+postscanl' = G.postscanl'
+
+-- | /O(n)/ Haskell-style scan
+--
+-- > scanl f z <x1,...,xn> = <y1,...,y(n+1)>
+-- >   where y1 = z
+-- >         yi = f y(i-1) x(i-1)
+--
+-- Example: @scanl (+) 0 \<1,2,3,4\> = \<0,1,3,6,10\>@
+-- 
+scanl :: (a -> b -> a) -> a -> Vector b -> Vector a
+{-# INLINE scanl #-}
+scanl = G.scanl
+
+-- | /O(n)/ Haskell-style scan with strict accumulator
+scanl' :: (a -> b -> a) -> a -> Vector b -> Vector a
+{-# INLINE scanl' #-}
+scanl' = G.scanl'
+
+-- | /O(n)/ Scan over a non-empty vector
+--
+-- > scanl f <x1,...,xn> = <y1,...,yn>
+-- >   where y1 = x1
+-- >         yi = f y(i-1) xi
+--
+scanl1 :: (a -> a -> a) -> Vector a -> Vector a
+{-# INLINE scanl1 #-}
+scanl1 = G.scanl1
+
+-- | /O(n)/ Scan over a non-empty vector with a strict accumulator
+scanl1' :: (a -> a -> a) -> Vector a -> Vector a
+{-# INLINE scanl1' #-}
+scanl1' = G.scanl1'
+
+-- | /O(n)/ Right-to-left prescan
+--
+-- @
+-- prescanr f z = 'reverse' . 'prescanl' (flip f) z . 'reverse'
+-- @
+--
+prescanr :: (a -> b -> b) -> b -> Vector a -> Vector b
+{-# INLINE prescanr #-}
+prescanr = G.prescanr
+
+-- | /O(n)/ Right-to-left prescan with strict accumulator
+prescanr' :: (a -> b -> b) -> b -> Vector a -> Vector b
+{-# INLINE prescanr' #-}
+prescanr' = G.prescanr'
+
+-- | /O(n)/ Right-to-left scan
+postscanr :: (a -> b -> b) -> b -> Vector a -> Vector b
+{-# INLINE postscanr #-}
+postscanr = G.postscanr
+
+-- | /O(n)/ Right-to-left scan with strict accumulator
+postscanr' :: (a -> b -> b) -> b -> Vector a -> Vector b
+{-# INLINE postscanr' #-}
+postscanr' = G.postscanr'
+
+-- | /O(n)/ Right-to-left Haskell-style scan
+scanr :: (a -> b -> b) -> b -> Vector a -> Vector b
+{-# INLINE scanr #-}
+scanr = G.scanr
+
+-- | /O(n)/ Right-to-left Haskell-style scan with strict accumulator
+scanr' :: (a -> b -> b) -> b -> Vector a -> Vector b
+{-# INLINE scanr' #-}
+scanr' = G.scanr'
+
+-- | /O(n)/ Right-to-left scan over a non-empty vector
+scanr1 :: (a -> a -> a) -> Vector a -> Vector a
+{-# INLINE scanr1 #-}
+scanr1 = G.scanr1
+
+-- | /O(n)/ Right-to-left scan over a non-empty vector with a strict
+-- accumulator
+scanr1' :: (a -> a -> a) -> Vector a -> Vector a
+{-# INLINE scanr1' #-}
+scanr1' = G.scanr1'
+
+-- Conversions - Lists
+-- ------------------------
+
+-- | /O(n)/ Convert a vector to a list
+toList :: Vector a -> [a]
+{-# INLINE toList #-}
+toList = G.toList
+
+-- | /O(n)/ Convert a list to a vector
+fromList :: [a] -> Vector a
+{-# INLINE fromList #-}
+fromList = G.fromList
+
+-- | /O(n)/ Convert the first @n@ elements of a list to a vector
+--
+-- @
+-- fromListN n xs = 'fromList' ('take' n xs)
+-- @
+fromListN :: Int -> [a] -> Vector a
+{-# INLINE fromListN #-}
+fromListN = G.fromListN
+
+-- Conversions - Mutable vectors
+-- -----------------------------
+
+-- | /O(1)/ Unsafe convert a mutable vector to an immutable one without
+-- copying. The mutable vector may not be used after this operation.
+unsafeFreeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)
+{-# INLINE unsafeFreeze #-}
+unsafeFreeze = G.unsafeFreeze
+
+-- | /O(1)/ Unsafely convert an immutable vector to a mutable one without
+-- copying. The immutable vector may not be used after this operation.
+unsafeThaw :: PrimMonad m => Vector a -> m (MVector (PrimState m) a)
+{-# INLINE unsafeThaw #-}
+unsafeThaw = G.unsafeThaw
+
+-- | /O(n)/ Yield a mutable copy of the immutable vector.
+thaw :: PrimMonad m => Vector a -> m (MVector (PrimState m) a)
+{-# INLINE thaw #-}
+thaw = G.thaw
+
+-- | /O(n)/ Yield an immutable copy of the mutable vector.
+freeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)
+{-# INLINE freeze #-}
+freeze = G.freeze
+
+-- | /O(n)/ Copy an immutable vector into a mutable one. The two vectors must
+-- have the same length. This is not checked.
+unsafeCopy :: PrimMonad m => MVector (PrimState m) a -> Vector a -> m ()
+{-# INLINE unsafeCopy #-}
+unsafeCopy = G.unsafeCopy
+           
+-- | /O(n)/ Copy an immutable vector into a mutable one. The two vectors must
+-- have the same length.
+copy :: PrimMonad m => MVector (PrimState m) a -> Vector a -> m ()
+{-# INLINE copy #-}
+copy = G.copy
+
diff --git a/Data/Vector/Unboxed/Base.hs b/Data/Vector/Unboxed/Base.hs
index 2d9822e..20b80d0 100644
--- a/Data/Vector/Unboxed/Base.hs
+++ b/Data/Vector/Unboxed/Base.hs
@@ -115,11 +115,14 @@ instance M.MVector MVector () where
   basicUnsafeGrow (MV_Unit n) m = return $ MV_Unit (n+m)
 
 instance G.Vector Vector () where
-  {-# INLINE basicUnsafeFreeze #-}
-  basicUnsafeFreeze (MV_Unit n) = return $ V_Unit n
+  {-# INLINE basicUnsafeCreate #-}
+  basicUnsafeCreate n = return $ V_Unit n
 
-  {-# INLINE basicUnsafeThaw #-}
-  basicUnsafeThaw (V_Unit n) = return $ MV_Unit n
+  {-# INLINE basicUnsafeInitElem #-}
+  basicUnsafeInitElem (V_Unit _) _ () = return ()
+
+  {-# INLINE basicUnsafeInited #-}
+  basicUnsafeInited v = return v
 
   {-# INLINE basicLength #-}
   basicLength (V_Unit n) = n
@@ -169,14 +172,17 @@ instance M.MVector MVector ty where {                                   \
 
 #define primVector(ty,con,mcon)                                         \
 instance G.Vector Vector ty where {                                     \
-  {-# INLINE basicUnsafeFreeze #-}                                      \
-; {-# INLINE basicUnsafeThaw #-}                                        \
+  {-# INLINE basicUnsafeCreate #-}                                      \
+; {-# INLINE basicUnsafeInitElem #-}                                    \
+; {-# INLINE basicUnsafeInited #-}                                      \
 ; {-# INLINE basicLength #-}                                            \
 ; {-# INLINE basicUnsafeSlice #-}                                       \
 ; {-# INLINE basicUnsafeIndexM #-}                                      \
 ; {-# INLINE elemseq #-}                                                \
-; basicUnsafeFreeze (mcon v) = con `liftM` G.basicUnsafeFreeze v        \
-; basicUnsafeThaw (con v) = mcon `liftM` G.basicUnsafeThaw v            \
+; basicUnsafeCreate n = do {a <- G.basicUnsafeCreate n; return $ con a} \
+; basicUnsafeInitElem (con v) i x = G.basicUnsafeInitElem v i x         \
+; basicUnsafeInited (con v) =                                           \
+    do {a <- G.basicUnsafeInited v; return $ con a}                     \
 ; basicLength (con v) = G.basicLength v                                 \
 ; basicUnsafeSlice i n (con v) = con $ G.basicUnsafeSlice i n v         \
 ; basicUnsafeIndexM (con v) i = G.basicUnsafeIndexM v i                 \
@@ -309,14 +315,13 @@ instance M.MVector MVector Bool where
   basicUnsafeGrow (MV_Bool v) n = MV_Bool `liftM` M.basicUnsafeGrow v n
 
 instance G.Vector Vector Bool where
-  {-# INLINE basicUnsafeFreeze #-}
-  {-# INLINE basicUnsafeThaw #-}
   {-# INLINE basicLength #-}
   {-# INLINE basicUnsafeSlice #-}
   {-# INLINE basicUnsafeIndexM #-}
   {-# INLINE elemseq #-}
-  basicUnsafeFreeze (MV_Bool v) = V_Bool `liftM` G.basicUnsafeFreeze v
-  basicUnsafeThaw (V_Bool v) = MV_Bool `liftM` G.basicUnsafeThaw v
+  basicUnsafeCreate n = do {a <- G.basicUnsafeCreate n; return $ V_Bool a}
+  basicUnsafeInitElem (V_Bool v) i x = G.basicUnsafeInitElem v i (fromBool x)
+  basicUnsafeInited (V_Bool v) = do {a <- G.basicUnsafeInited v; return $ V_Bool a}
   basicLength (V_Bool v) = G.basicLength v
   basicUnsafeSlice i n (V_Bool v) = V_Bool $ G.basicUnsafeSlice i n v
   basicUnsafeIndexM (V_Bool v) i = toBool `liftM` G.basicUnsafeIndexM v i
@@ -358,14 +363,13 @@ instance (RealFloat a, Unbox a) => M.MVector MVector (Complex a) where
   basicUnsafeGrow (MV_Complex v) n = MV_Complex `liftM` M.basicUnsafeGrow v n
 
 instance (RealFloat a, Unbox a) => G.Vector Vector (Complex a) where
-  {-# INLINE basicUnsafeFreeze #-}
-  {-# INLINE basicUnsafeThaw #-}
   {-# INLINE basicLength #-}
   {-# INLINE basicUnsafeSlice #-}
   {-# INLINE basicUnsafeIndexM #-}
   {-# INLINE elemseq #-}
-  basicUnsafeFreeze (MV_Complex v) = V_Complex `liftM` G.basicUnsafeFreeze v
-  basicUnsafeThaw (V_Complex v) = MV_Complex `liftM` G.basicUnsafeThaw v
+  basicUnsafeCreate n = do {a <- G.basicUnsafeCreate n; return $ V_Complex a}
+  basicUnsafeInitElem (V_Complex v) i (x :+ y) = G.basicUnsafeInitElem v i (x,y)
+  basicUnsafeInited (V_Complex v) = do {a <- G.basicUnsafeInited v; return $ V_Complex a}
   basicLength (V_Complex v) = G.basicLength v
   basicUnsafeSlice i n (V_Complex v) = V_Complex $ G.basicUnsafeSlice i n v
   basicUnsafeIndexM (V_Complex v) i
diff --git a/hrc-notes.txt b/hrc-notes.txt
new file mode 100644
index 0000000..b5b8a15
--- /dev/null
+++ b/hrc-notes.txt
@@ -0,0 +1,156 @@
+Implementation strategy
+=======================
+
+Primitives
+----------
+
+Added three new types: immutable arrays, strict immutable arrays, and
+unboxed arrays.  Generally these arrays have the following operations
+on them, subject to the notes below.
+
+new : size -> state -> (# state, array #)
+  Creates a new uninitialised array.
+  Constract is that elements must be initialised at most once
+  and must be initialised below being read.
+
+init : array -> index -> element -> state -> state
+  Initialises one element of the array.
+  Contract is that elements must be initialised at most once.
+
+inited : array -> state -> (# state, array #)
+  Sets the array as inited.  This is useful in hrc to set the
+  vtable to always immutable.  It is also needed to prevent
+  GHC from optimising reads after the runST into and before the
+  actual initialisation.
+
+sizeof : array -> size
+  Returns the length of the array.
+
+index : array -> index -> element
+  Reads an element of the array.
+  Contract is that the element must be initialised before being
+  read.
+  For the boxed arrays, the element is return an unboxed tuple
+  (i.e. the return type is actually (# element #)).  This avoids
+  forcing the element for the lazy arrays.  For strict arrays this is
+  necessary as GHC can't handle a return type of a.
+
+The types are:
+
+ImmutableArray# a
+  Polymorphic lazy boxed arrays.
+
+StrictImmutableArray# a
+  Polymorphic strict boxed arrays.
+
+UnboxedXArray#
+  Monomorphic strict unboxed arrays of primitive types.
+  For each X a primitive type (Word, Word8, Word16, Word32, Word64,
+  Int, Int8, Int16, Int32, Int64, Float, Double, Char, Addr) there is
+  one of these array types and corresponding operations.  Note that
+  the element type is X#.
+  For 8 and 16 bit sizes, the operations take/return a Word# or Int#
+  rather than a Word8# etc.  These are cast to/from the actual element
+  type used in the array.
+  For 32 bit, the operations take/return a Word# or Int# on a 32-bit
+  platform and a Word32# or Int32# on a 64-bit platform.  (Of course
+  Word# and Word32# are the same in this case.)
+  For 64 bit, the operations take/return a Word# or Int# on a 64-bit
+  platform and a Word64# or Int64# on a 32-bit platform.
+
+Note that on GHC, the new operations are not actually implemented and
+that the strict boxed arrays are actually no different from the lazy
+boxed arrays.  Everything is correctly implemented in
+
+Primitive Package
+-----------------
+
+Added new modules for our immutable, strict, and unboxed arrays:
+  Data.Primitive.ImmutableArray
+  Data.Primitive.StrictImmutableArray
+  Data.Primitive.UnboxedArrayTypes
+  Data.Primitive.UnboxedArray
+These modules currently exposed boxed versions of the array types (the
+primitives types are strict types, the boxed versions are lazy types,
+although both are implemented as pointers to heap objects), Typeable
+instances, and the new, init, inited, and index operations.  Unboxed arrays
+are split into two modules to avoid a mutual dependency with
+Data.Primitive.Types.
+
+In Data.Primitive.Types:
+
+  Added a type family UnboxedArray to map a primitive type to the type
+  of strict unboxed immutable arrays for it.
+
+  Modified the Prim class to include newUnboxedArray,
+  initUnboxedArray, unboxedArrayInited, and indexUnboxedArray
+  operations for creating and accessing the corresponding unboxed
+  arrays.
+
+  Modified the instances of this class to include the use of the
+  corresponding new primitives for these operations for the various
+  primitive types.
+
+Generic vectors
+---------------
+
+Generic interface:
+  Remove basicUnsafeFreeze and basicUnsafeThaw.
+  Add basicUnsafeCreate, basicUnsafeInit, and basicUnsafeInited.
+  Default implementation of basicUnsafeCopy is a loop that copies
+  using basic unsafe reading and writing of the two arrays.
+  Add basicUnsafeGrow with default implementation that allocates
+  new vector and copies elements over.
+  Add basicUnsafeCopyI that copies an immutable vector to another
+  immutable vector with default implementation based on a loop using
+  basicUnsafeIndex and basicUnsafeInitElem.
+
+Replaced the force, freeze, unstream, unstreamR, partition_stream, and
+unstablePartition_stream operations with better implementation.  Note
+that I use similar implementation to the mutable generic
+implementation.  In particular, for unknown streams, use a logarithmic
+enlarging scheme.  Note also that these unstream and partition stream
+implementations are not space efficient and might leak space - force
+should fix that.
+
+unsafeFreeze & unsafeThaw are not implemented (use error)
+
+Lazy Boxed Vectors
+--------------------
+
+Modified Vector.hs to use the new ImmutableArray to immutable vectors
+and implemented the new basic interface operations using the
+corresponding immutable array operations.
+
+Strict Boxed Vectors
+--------------------
+
+Added a new Data.Vector.Strict class for strict boxed vectors.  I
+copied Vector.hs for this and modified it to use
+StrictImmutableArray.  Otherwise the same.  In particular the mutable
+vectors here are the same as the lazy case, and thus are lazy not
+strict.
+
+Primitive Vectors
+-----------------
+
+Modified Primitive.hs to use UnboxedArray a from Data.Primitive.Types
+- namely the new type family for the strict unboxed arrays for
+primitive types.  Modified the vector implementation of basic
+operations to use the corresponding operations from the Prim class.
+
+Removed the overriding implementation of basicUnsafeCopy, use the
+default instead.  For large vector of primitives, it might be better
+to use a memcpy, so it might be better to implement this in the
+future.
+
+Unboxed Vectors
+---------------
+
+Minor modifications to Data.Vector.Unboxed.Base to implement the new
+basic operations of the generic interface in terms of the underlying
+operations of the primitive vectors and/or obvious implementations for
+unit.
+
+Modified unbox-tuple-instances to lift the new basic operations to
+tuples (and removed the old freeze and thaw liftings).
diff --git a/internal/unbox-tuple-instances b/internal/unbox-tuple-instances
index 9cf5e35..a2809ef 100644
--- a/internal/unbox-tuple-instances
+++ b/internal/unbox-tuple-instances
@@ -67,18 +67,20 @@ instance (Unbox a, Unbox b) => M.MVector MVector (a, b) where
           bs' <- M.basicUnsafeGrow bs m_
           return $ MV_2 (m_+n_) as' bs'
 instance (Unbox a, Unbox b) => G.Vector Vector (a, b) where
-  {-# INLINE basicUnsafeFreeze  #-}
-  basicUnsafeFreeze (MV_2 n_ as bs)
-      = do
-          as' <- G.basicUnsafeFreeze as
-          bs' <- G.basicUnsafeFreeze bs
-          return $ V_2 n_ as' bs'
-  {-# INLINE basicUnsafeThaw  #-}
-  basicUnsafeThaw (V_2 n_ as bs)
-      = do
-          as' <- G.basicUnsafeThaw as
-          bs' <- G.basicUnsafeThaw bs
-          return $ MV_2 n_ as' bs'
+  {-# INLINE basicUnsafeCreate #-}
+  basicUnsafeCreate n = do
+    as <- G.basicUnsafeCreate n
+    bs <- G.basicUnsafeCreate n
+    return $ V_2 n as bs
+  {-# INLINE basicUnsafeInitElem #-}
+  basicUnsafeInitElem (V_2 n_ as bs) i (a,b) = do
+    G.basicUnsafeInitElem as i a
+    G.basicUnsafeInitElem bs i b
+  {-# INLINE basicUnsafeInited #-}
+  basicUnsafeInited (V_2 n as bs) = do
+    as' <- G.basicUnsafeInited as
+    bs' <- G.basicUnsafeInited bs
+    return $ V_2 n as' bs'
   {-# INLINE basicLength  #-}
   basicLength (V_2 n_ as bs) = n_
   {-# INLINE basicUnsafeSlice  #-}
@@ -216,20 +218,23 @@ instance (Unbox a,
 instance (Unbox a,
           Unbox b,
           Unbox c) => G.Vector Vector (a, b, c) where
-  {-# INLINE basicUnsafeFreeze  #-}
-  basicUnsafeFreeze (MV_3 n_ as bs cs)
-      = do
-          as' <- G.basicUnsafeFreeze as
-          bs' <- G.basicUnsafeFreeze bs
-          cs' <- G.basicUnsafeFreeze cs
-          return $ V_3 n_ as' bs' cs'
-  {-# INLINE basicUnsafeThaw  #-}
-  basicUnsafeThaw (V_3 n_ as bs cs)
-      = do
-          as' <- G.basicUnsafeThaw as
-          bs' <- G.basicUnsafeThaw bs
-          cs' <- G.basicUnsafeThaw cs
-          return $ MV_3 n_ as' bs' cs'
+  {-# INLINE basicUnsafeCreate #-}
+  basicUnsafeCreate n = do
+    as <- G.basicUnsafeCreate n
+    bs <- G.basicUnsafeCreate n
+    cs <- G.basicUnsafeCreate n
+    return $ V_3 n as bs cs
+  {-# INLINE basicUnsafeInitElem #-}
+  basicUnsafeInitElem (V_3 n_ as bs cs) i (a,b,c) = do
+    G.basicUnsafeInitElem as i a
+    G.basicUnsafeInitElem bs i b
+    G.basicUnsafeInitElem cs i c
+  {-# INLINE basicUnsafeInited #-}
+  basicUnsafeInited (V_3 n as bs cs) = do
+    as' <- G.basicUnsafeInited as
+    bs' <- G.basicUnsafeInited bs
+    cs' <- G.basicUnsafeInited cs
+    return $ V_3 n as' bs' cs'
   {-# INLINE basicLength  #-}
   basicLength (V_3 n_ as bs cs) = n_
   {-# INLINE basicUnsafeSlice  #-}
@@ -406,22 +411,26 @@ instance (Unbox a,
           Unbox b,
           Unbox c,
           Unbox d) => G.Vector Vector (a, b, c, d) where
-  {-# INLINE basicUnsafeFreeze  #-}
-  basicUnsafeFreeze (MV_4 n_ as bs cs ds)
-      = do
-          as' <- G.basicUnsafeFreeze as
-          bs' <- G.basicUnsafeFreeze bs
-          cs' <- G.basicUnsafeFreeze cs
-          ds' <- G.basicUnsafeFreeze ds
-          return $ V_4 n_ as' bs' cs' ds'
-  {-# INLINE basicUnsafeThaw  #-}
-  basicUnsafeThaw (V_4 n_ as bs cs ds)
-      = do
-          as' <- G.basicUnsafeThaw as
-          bs' <- G.basicUnsafeThaw bs
-          cs' <- G.basicUnsafeThaw cs
-          ds' <- G.basicUnsafeThaw ds
-          return $ MV_4 n_ as' bs' cs' ds'
+  {-# INLINE basicUnsafeCreate #-}
+  basicUnsafeCreate n = do
+    as <- G.basicUnsafeCreate n
+    bs <- G.basicUnsafeCreate n
+    cs <- G.basicUnsafeCreate n
+    ds <- G.basicUnsafeCreate n
+    return $ V_4 n as bs cs ds
+  {-# INLINE basicUnsafeInitElem #-}
+  basicUnsafeInitElem (V_4 n_ as bs cs ds) i (a,b,c,d) = do
+    G.basicUnsafeInitElem as i a
+    G.basicUnsafeInitElem bs i b
+    G.basicUnsafeInitElem cs i c
+    G.basicUnsafeInitElem ds i d
+  {-# INLINE basicUnsafeInited #-}
+  basicUnsafeInited (V_4 n as bs cs ds) = do
+    as' <- G.basicUnsafeInited as
+    bs' <- G.basicUnsafeInited bs
+    cs' <- G.basicUnsafeInited cs
+    ds' <- G.basicUnsafeInited ds
+    return $ V_4 n as' bs' cs' ds'
   {-# INLINE basicLength  #-}
   basicLength (V_4 n_ as bs cs ds) = n_
   {-# INLINE basicUnsafeSlice  #-}
@@ -647,24 +656,29 @@ instance (Unbox a,
           Unbox c,
           Unbox d,
           Unbox e) => G.Vector Vector (a, b, c, d, e) where
-  {-# INLINE basicUnsafeFreeze  #-}
-  basicUnsafeFreeze (MV_5 n_ as bs cs ds es)
-      = do
-          as' <- G.basicUnsafeFreeze as
-          bs' <- G.basicUnsafeFreeze bs
-          cs' <- G.basicUnsafeFreeze cs
-          ds' <- G.basicUnsafeFreeze ds
-          es' <- G.basicUnsafeFreeze es
-          return $ V_5 n_ as' bs' cs' ds' es'
-  {-# INLINE basicUnsafeThaw  #-}
-  basicUnsafeThaw (V_5 n_ as bs cs ds es)
-      = do
-          as' <- G.basicUnsafeThaw as
-          bs' <- G.basicUnsafeThaw bs
-          cs' <- G.basicUnsafeThaw cs
-          ds' <- G.basicUnsafeThaw ds
-          es' <- G.basicUnsafeThaw es
-          return $ MV_5 n_ as' bs' cs' ds' es'
+  {-# INLINE basicUnsafeCreate #-}
+  basicUnsafeCreate n = do
+    as <- G.basicUnsafeCreate n
+    bs <- G.basicUnsafeCreate n
+    cs <- G.basicUnsafeCreate n
+    ds <- G.basicUnsafeCreate n
+    es <- G.basicUnsafeCreate n
+    return $ V_5 n as bs cs ds es
+  {-# INLINE basicUnsafeInitElem #-}
+  basicUnsafeInitElem (V_5 n_ as bs cs ds es) i (a,b,c,d,e) = do
+    G.basicUnsafeInitElem as i a
+    G.basicUnsafeInitElem bs i b
+    G.basicUnsafeInitElem cs i c
+    G.basicUnsafeInitElem ds i d
+    G.basicUnsafeInitElem es i e
+  {-# INLINE basicUnsafeInited #-}
+  basicUnsafeInited (V_5 n as bs cs ds es) = do
+    as' <- G.basicUnsafeInited as
+    bs' <- G.basicUnsafeInited bs
+    cs' <- G.basicUnsafeInited cs
+    ds' <- G.basicUnsafeInited ds
+    es' <- G.basicUnsafeInited es
+    return $ V_5 n as' bs' cs' ds' es'
   {-# INLINE basicLength  #-}
   basicLength (V_5 n_ as bs cs ds es) = n_
   {-# INLINE basicUnsafeSlice  #-}
@@ -937,26 +951,32 @@ instance (Unbox a,
           Unbox d,
           Unbox e,
           Unbox f) => G.Vector Vector (a, b, c, d, e, f) where
-  {-# INLINE basicUnsafeFreeze  #-}
-  basicUnsafeFreeze (MV_6 n_ as bs cs ds es fs)
-      = do
-          as' <- G.basicUnsafeFreeze as
-          bs' <- G.basicUnsafeFreeze bs
-          cs' <- G.basicUnsafeFreeze cs
-          ds' <- G.basicUnsafeFreeze ds
-          es' <- G.basicUnsafeFreeze es
-          fs' <- G.basicUnsafeFreeze fs
-          return $ V_6 n_ as' bs' cs' ds' es' fs'
-  {-# INLINE basicUnsafeThaw  #-}
-  basicUnsafeThaw (V_6 n_ as bs cs ds es fs)
-      = do
-          as' <- G.basicUnsafeThaw as
-          bs' <- G.basicUnsafeThaw bs
-          cs' <- G.basicUnsafeThaw cs
-          ds' <- G.basicUnsafeThaw ds
-          es' <- G.basicUnsafeThaw es
-          fs' <- G.basicUnsafeThaw fs
-          return $ MV_6 n_ as' bs' cs' ds' es' fs'
+  {-# INLINE basicUnsafeCreate #-}
+  basicUnsafeCreate n = do
+    as <- G.basicUnsafeCreate n
+    bs <- G.basicUnsafeCreate n
+    cs <- G.basicUnsafeCreate n
+    ds <- G.basicUnsafeCreate n
+    es <- G.basicUnsafeCreate n
+    fs <- G.basicUnsafeCreate n
+    return $ V_6 n as bs cs ds es fs
+  {-# INLINE basicUnsafeInitElem #-}
+  basicUnsafeInitElem (V_6 n_ as bs cs ds es fs) i (a,b,c,d,e,f) = do
+    G.basicUnsafeInitElem as i a
+    G.basicUnsafeInitElem bs i b
+    G.basicUnsafeInitElem cs i c
+    G.basicUnsafeInitElem ds i d
+    G.basicUnsafeInitElem es i e
+    G.basicUnsafeInitElem fs i f
+  {-# INLINE basicUnsafeInited #-}
+  basicUnsafeInited (V_6 n as bs cs ds es fs) = do
+    as' <- G.basicUnsafeInited as
+    bs' <- G.basicUnsafeInited bs
+    cs' <- G.basicUnsafeInited cs
+    ds' <- G.basicUnsafeInited ds
+    es' <- G.basicUnsafeInited es
+    fs' <- G.basicUnsafeInited fs
+    return $ V_6 n as' bs' cs' ds' es' fs'
   {-# INLINE basicLength  #-}
   basicLength (V_6 n_ as bs cs ds es fs) = n_
   {-# INLINE basicUnsafeSlice  #-}
diff --git a/vector.cabal b/vector.cabal
index 279aaf4..aa39753 100644
--- a/vector.cabal
+++ b/vector.cabal
@@ -153,6 +153,8 @@ Library
         Data.Vector.Storable.Mutable
         Data.Vector.Storable
 
+        Data.Vector.Strict
+
         Data.Vector.Unboxed.Base
         Data.Vector.Unboxed.Mutable
         Data.Vector.Unboxed.Mutable.Safe
