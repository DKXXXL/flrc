diff --git a/GHC/Integer.hs b/GHC/Integer.hs
index c9b50a7..a3e70b5 100644
--- a/GHC/Integer.hs
+++ b/GHC/Integer.hs
@@ -27,14 +27,174 @@ module GHC.Integer (
     plusInteger, minusInteger, timesInteger, negateInteger,
     eqInteger, neqInteger, absInteger, signumInteger,
     leInteger, gtInteger, ltInteger, geInteger, compareInteger,
+    divInteger, modInteger,
     divModInteger, quotRemInteger, quotInteger, remInteger,
     encodeFloatInteger, decodeFloatInteger, floatFromInteger,
     encodeDoubleInteger, decodeDoubleInteger, doubleFromInteger,
     -- gcdInteger, lcmInteger, -- XXX
     andInteger, orInteger, xorInteger, complementInteger,
     shiftLInteger, shiftRInteger,
-    hashInteger,
+    hashInteger, zeroInteger, oneInteger, twoInteger
  ) where
 
-import GHC.Integer.Type
+import GHC.Integer.Internals (Integer, zeroInteger, oneInteger, twoInteger)
+import qualified GHC.Integer.Internals as I
+import GHC.Prim
+import GHC.Classes
+import GHC.Types
+#if WORD_SIZE_IN_BITS < 64
+import GHC.IntWord64()
+#endif
+--default ()
+#if !defined(__HADDOCK__)
+
+{-# NOINLINE mkInteger #-}
+mkInteger :: Bool   -- non-negative?
+          -> [Int]  -- absolute value in 31 bit chunks, least significant first
+                    -- ideally these would be Words rather than Ints, but
+                    -- we don't have Word available at the moment.
+          -> Integer
+mkInteger nonNegative is = let abs = f is
+                           in if nonNegative then abs else negateInteger abs
+    where f [] = I.zeroInteger
+          f (I# i : is') = smallInteger i `orInteger` shiftLInteger (f is') 31#
+
+smallInteger :: Int# -> Integer
+smallInteger !i = I.smallInteger i
+
+wordToInteger :: Word# -> Integer
+wordToInteger !i = I.wordToInteger i
+
+integerToWord :: Integer -> Word#
+integerToWord !i = I.integerToWord i
+
+integerToInt :: Integer -> Int#
+integerToInt !i = I.integerToInt i
+
+#if WORD_SIZE_IN_BITS == 64
+-- Nothing
+#elif WORD_SIZE_IN_BITS == 32
+integerToWord64 :: Integer -> Word64#
+integerToWord64 !i = I.integerToWord64 i
+
+word64ToInteger :: Word64# -> Integer
+word64ToInteger !i = I.word64ToInteger i
+
+integerToInt64 :: Integer -> Int64#
+integerToInt64 !i = I.integerToInt64 i
+
+int64ToInteger :: Int64# -> Integer
+int64ToInteger !i = I.int64ToInteger i
+#else
+#error WORD_SIZE_IN_BITS not supported
+#endif
+
+encodeDoubleInteger :: Integer -> Int# -> Double#
+encodeDoubleInteger !i !j = I.encodeDoubleInteger i j
+
+encodeFloatInteger :: Integer -> Int# -> Float#
+encodeFloatInteger !i !j = I.encodeFloatInteger i j
+
+decodeFloatInteger :: Float# -> (# Integer, Int# #)
+decodeFloatInteger !f = I.decodeFloatInteger f
+
+decodeDoubleInteger :: Double# -> (# Integer, Int# #)
+decodeDoubleInteger !d = I.decodeDoubleInteger d
+
+doubleFromInteger :: Integer -> Double#
+doubleFromInteger !i = I.doubleFromInteger i
+
+floatFromInteger :: Integer -> Float#
+floatFromInteger !i = I.floatFromInteger i
+
+andInteger :: Integer -> Integer -> Integer
+andInteger !i !j = I.andInteger i j
+
+orInteger :: Integer -> Integer -> Integer
+orInteger !i !j = I.orInteger i j
+
+xorInteger :: Integer -> Integer -> Integer
+xorInteger !i !j = I.xorInteger i j
+
+complementInteger :: Integer -> Integer
+complementInteger !i = I.complementInteger i
+
+shiftLInteger :: Integer -> Int# -> Integer
+shiftLInteger !i !j = I.shiftLInteger i j
+
+shiftRInteger :: Integer -> Int# -> Integer
+shiftRInteger !i !j = I.shiftRInteger i j
+
+negateInteger :: Integer -> Integer
+negateInteger !i = I.negateInteger i
+
+plusInteger :: Integer -> Integer -> Integer
+plusInteger !i !j = I.plusInteger i j
+
+minusInteger :: Integer -> Integer -> Integer
+minusInteger !i !j = I.minusInteger i j
+
+timesInteger :: Integer -> Integer -> Integer
+timesInteger !i !j = I.timesInteger i j
+
+divModInteger :: Integer -> Integer -> (# Integer, Integer #)
+divModInteger !i !j = I.divModInteger i j
+
+quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)
+quotRemInteger !i !j = I.quotRemInteger i j
+
+divInteger :: Integer -> Integer -> Integer
+divInteger !i !j = I.divInteger i j
+
+modInteger :: Integer -> Integer -> Integer
+modInteger !i !j = I.modInteger i j
+
+quotInteger :: Integer -> Integer -> Integer
+quotInteger !i !j = I.quotInteger i j
+
+remInteger :: Integer -> Integer -> Integer
+remInteger !i !j = I.remInteger i j
+
+compareInteger :: Integer -> Integer -> Ordering
+compareInteger !i !j = I.compareInteger i j
+
+eqInteger :: Integer -> Integer -> Bool
+eqInteger !i !j = I.eqInteger i j
+
+neqInteger :: Integer -> Integer -> Bool
+neqInteger !i !j = I.neqInteger i j
+
+ltInteger :: Integer -> Integer -> Bool
+ltInteger !i !j = I.ltInteger i j
+
+gtInteger :: Integer -> Integer -> Bool
+gtInteger !i !j = I.gtInteger i j
+
+leInteger :: Integer -> Integer -> Bool
+leInteger !i !j = I.leInteger i j
+
+geInteger :: Integer -> Integer -> Bool
+geInteger !i !j = I.geInteger i j
+
+absInteger :: Integer -> Integer
+absInteger !i = I.absInteger i 
+
+signumInteger :: Integer -> Integer
+signumInteger !i = I.signumInteger i
+
+hashInteger :: Integer -> Int#
+hashInteger !i = I.hashInteger i
+
+instance Eq Integer where
+  (==) = eqInteger
+  (/=) = neqInteger
+
+instance Ord Integer where
+    (<=) = leInteger
+    (>)  = gtInteger
+    (<)  = ltInteger
+    (>=) = geInteger
+    compare = compareInteger
+
+#endif
 
diff --git a/GHC/Integer/Internals.hs b/GHC/Integer/Internals.hs
new file mode 100644
index 0000000..aba2558
--- /dev/null
+++ b/GHC/Integer/Internals.hs
@@ -0,0 +1,813 @@
+
+{-# LANGUAGE CPP, MagicHash, ForeignFunctionInterface,
+             NoImplicitPrelude, BangPatterns, UnboxedTuples,
+             UnliftedFFITypes #-}
+
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  GHC.Integer
+-- Copyright   :  (c) Ian Lynagh 2007-2008
+-- License     :  BSD3
+--
+-- Maintainer  :  igloo@earth.li
+-- Stability   :  internal
+-- Portability :  non-portable (GHC Extensions)
+--
+-- An simple definition of the 'Integer' type.
+--
+-----------------------------------------------------------------------------
+
+#include "MachDeps.h"
+
+module GHC.Integer.Internals (
+    Integer(..), Digits (..), List (..),
+    smallInteger, wordToInteger, integerToWord, integerToInt,
+#if WORD_SIZE_IN_BITS < 64
+    integerToWord64, word64ToInteger,
+    integerToInt64, int64ToInteger,
+#endif
+    plusInteger, minusInteger, timesInteger, negateInteger,
+    eqInteger, neqInteger, absInteger, signumInteger,
+    leInteger, gtInteger, ltInteger, geInteger, compareInteger,
+    divInteger, modInteger,
+    divModInteger, quotRemInteger, quotInteger, remInteger,
+    encodeFloatInteger, decodeFloatInteger, floatFromInteger,
+    encodeDoubleInteger, decodeDoubleInteger, doubleFromInteger,
+    -- gcdInteger, lcmInteger, -- XXX
+    andInteger, orInteger, xorInteger, complementInteger,
+    shiftLInteger, shiftRInteger,
+    hashInteger,
+    zeroInteger, oneInteger, twoInteger
+ ) where
+
+import GHC.Prim
+import GHC.Types
+import GHC.Integer.Type
+#if WORD_SIZE_IN_BITS < 64
+import GHC.IntWord64
+#endif
+
+#if !defined(__HADDOCK__)
+
+errorInteger :: Integer
+errorInteger = Positive errorPositive
+
+errorPositive :: Positive
+errorPositive = Some 47## None -- Random number
+
+{-# NOINLINE smallInteger #-}
+smallInteger :: Int# -> Integer
+smallInteger i = if i >=# 0# then wordToInteger (int2Word# i)
+                 else -- XXX is this right for -minBound?
+                      negateInteger (wordToInteger (int2Word# (negateInt# i)))
+
+{-# NOINLINE wordToInteger #-}
+wordToInteger :: Word# -> Integer
+wordToInteger w = if w `eqWord#` 0##
+                  then Naught
+                  else Positive (Some w None)
+
+{-# RULES
+"integerToInt/smallInteger"   forall x . integerToInt  (smallInteger  x) = x
+"integerToWord/wordToInteger" forall x . integerToWord (wordToInteger x) = x
+ #-}
+
+{-# NOINLINE integerToWord #-}
+integerToWord :: Integer -> Word#
+integerToWord (Positive (Some w _)) = w
+integerToWord (Negative (Some w _)) = 0## `minusWord#` w
+-- Must be Naught by the invariant:
+integerToWord _ = 0##
+
+{-# NOINLINE integerToInt #-}
+integerToInt :: Integer -> Int#
+integerToInt !i = word2Int# (integerToWord i)
+
+#if WORD_SIZE_IN_BITS == 64
+-- Nothing
+#elif WORD_SIZE_IN_BITS == 32
+{-# NOINLINE integerToWord64 #-}
+integerToWord64 :: Integer -> Word64#
+integerToWord64 !i = int64ToWord64# (integerToInt64 i)
+
+{-# NOINLINE word64ToInteger #-}
+word64ToInteger :: Word64# -> Integer
+word64ToInteger w = if w `eqWord64#` wordToWord64# 0##
+                    then Naught
+                    else Positive (word64ToPositive w)
+
+{-# RULES
+"integerToInt64/int64ToInteger"   forall x . integerToInt64  (int64ToInteger  x) = x
+"integerToWord64/word64ToInteger" forall x . integerToWord64 (word64ToInteger x) = x
+ #-}
+
+{-# NOINLINE integerToInt64 #-}
+integerToInt64 :: Integer -> Int64#
+integerToInt64 Naught = intToInt64# 0#
+integerToInt64 (Positive p) = word64ToInt64# (positiveToWord64 p)
+integerToInt64 (Negative p)
+    = negateInt64# (word64ToInt64# (positiveToWord64 p))
+
+{-# NOINLINE int64ToInteger #-}
+int64ToInteger :: Int64# -> Integer
+int64ToInteger i
+ = if i `eqInt64#` intToInt64# 0#
+   then Naught
+   else if i `gtInt64#` intToInt64# 0#
+   then Positive (word64ToPositive (int64ToWord64# i))
+   else Negative (word64ToPositive (int64ToWord64# (negateInt64# i)))
+#else
+#error WORD_SIZE_IN_BITS not supported
+#endif
+
+negativeOneInteger :: Integer
+negativeOneInteger = Negative onePositive
+
+twoToTheThirtytwoInteger :: Integer
+twoToTheThirtytwoInteger = Positive twoToTheThirtytwoPositive
+
+{-# NOINLINE encodeDoubleInteger #-}
+encodeDoubleInteger :: Integer -> Int# -> Double#
+encodeDoubleInteger (Positive ds0) e0 = f 0.0## ds0 e0
+    where f !acc None        (!_) = acc
+          f !acc (Some d ds) !e   = f (acc +## encodeDouble# d e)
+                                      ds
+                                      -- XXX We assume that this adding to e
+                                      -- isn't going to overflow
+                                      (e +# WORD_SIZE_IN_BITS#)
+encodeDoubleInteger (Negative ds) e
+    = negateDouble# (encodeDoubleInteger (Positive ds) e)
+encodeDoubleInteger Naught _ = 0.0##
+
+foreign import ccall unsafe "__word_encodeDouble"
+        encodeDouble# :: Word# -> Int# -> Double#
+
+{-# NOINLINE encodeFloatInteger #-}
+encodeFloatInteger :: Integer -> Int# -> Float#
+encodeFloatInteger (Positive ds0) e0 = f 0.0# ds0 e0
+    where f !acc None        (!_) = acc
+          f !acc (Some d ds) !e   = f (acc `plusFloat#` encodeFloat# d e)
+                                      ds
+                                      -- XXX We assume that this adding to e
+                                      -- isn't going to overflow
+                                      (e +# WORD_SIZE_IN_BITS#)
+encodeFloatInteger (Negative ds) e
+    = negateFloat# (encodeFloatInteger (Positive ds) e)
+encodeFloatInteger Naught _ = 0.0#
+
+foreign import ccall unsafe "__word_encodeFloat"
+    encodeFloat# :: Word# -> Int# -> Float#
+
+{-# NOINLINE decodeFloatInteger #-}
+decodeFloatInteger :: Float# -> (# Integer, Int# #)
+decodeFloatInteger f = case decodeFloat_Int# f of
+                       (# mant, exp #) -> (# smallInteger mant, exp #)
+
+-- XXX This could be optimised better, by either (word-size dependent)
+-- using single 64bit value for the mantissa, or doing the multiplication
+-- by just building the Digits directly
+{-# NOINLINE decodeDoubleInteger #-}
+decodeDoubleInteger :: Double# -> (# Integer, Int# #)
+decodeDoubleInteger d
+ = case decodeDouble_2Int# d of
+   (# mantSign, mantHigh, mantLow, exp #) ->
+       (# (smallInteger mantSign) `timesInteger`
+          (  (wordToInteger mantHigh `timesInteger` twoToTheThirtytwoInteger)
+             `plusInteger` wordToInteger mantLow),
+          exp #)
+
+{-# NOINLINE doubleFromInteger #-}
+doubleFromInteger :: Integer -> Double#
+doubleFromInteger Naught = 0.0##
+doubleFromInteger (Positive p) = doubleFromPositive p
+doubleFromInteger (Negative p) = negateDouble# (doubleFromPositive p)
+
+{-# NOINLINE floatFromInteger #-}
+floatFromInteger :: Integer -> Float#
+floatFromInteger Naught = 0.0#
+floatFromInteger (Positive p) = floatFromPositive p
+floatFromInteger (Negative p) = negateFloat# (floatFromPositive p)
+
+{-# NOINLINE andInteger #-}
+andInteger :: Integer -> Integer -> Integer
+Naught     `andInteger` (!_)       = Naught
+(!_)       `andInteger` Naught     = Naught
+Positive x `andInteger` Positive y = digitsToInteger (x `andDigits` y)
+{-
+To calculate x & -y we need to calculate
+    x & twosComplement y
+The (imaginary) sign bits are 0 and 1, so &ing them give 0, i.e. positive.
+Note that
+    twosComplement y
+has infinitely many 1s, but x has a finite number of digits, so andDigits
+will return a finite result.
+-}
+Positive x `andInteger` Negative y = let y' = twosComplementPositive y
+                                         z = y' `andDigitsOnes` x
+                                     in digitsToInteger z
+Negative x `andInteger` Positive y = Positive y `andInteger` Negative x
+{-
+To calculate -x & -y, naively we need to calculate
+    twosComplement (twosComplement x & twosComplement y)
+but
+    twosComplement x & twosComplement y
+has infinitely many 1s, so this won't work. Thus we use de Morgan's law
+to get
+    -x & -y = !(!(-x) | !(-y))
+            = !(!(twosComplement x) | !(twosComplement y))
+            = !(!(!x + 1) | (!y + 1))
+            = !((x - 1) | (y - 1))
+but the result is negative, so we need to take the two's complement of
+this in order to get the magnitude of the result.
+    twosComplement !((x - 1) | (y - 1))
+            = !(!((x - 1) | (y - 1))) + 1
+            = ((x - 1) | (y - 1)) + 1
+-}
+-- We don't know that x and y are /strictly/ greater than 1, but
+-- minusPositive gives us the required answer anyway.
+Negative x `andInteger` Negative y = let x' = x `minusPositive` onePositive
+                                         y' = y `minusPositive` onePositive
+                                         z = x' `orDigits` y'
+                                         -- XXX Cheating the precondition:
+                                         z' = succPositive z
+                                     in digitsToNegativeInteger z'
+
+{-# NOINLINE orInteger #-}
+orInteger :: Integer -> Integer -> Integer
+Naught     `orInteger` (!i)       = i
+(!i)       `orInteger` Naught     = i
+Positive x `orInteger` Positive y = Positive (x `orDigits` y)
+{-
+x | -y = - (twosComplement (x | twosComplement y))
+       = - (twosComplement !(!x & !(twosComplement y)))
+       = - (twosComplement !(!x & !(!y + 1)))
+       = - (twosComplement !(!x & (y - 1)))
+       = - ((!x & (y - 1)) + 1)
+-}
+Positive x `orInteger` Negative y = let x' = flipBits x
+                                        y' = y `minusPositive` onePositive
+                                        z = x' `andDigitsOnes` y'
+                                        z' = succPositive z
+                                    in digitsToNegativeInteger z'
+Negative x `orInteger` Positive y = Positive y `orInteger` Negative x
+{-
+-x | -y = - (twosComplement (twosComplement x | twosComplement y))
+        = - (twosComplement !(!(twosComplement x) & !(twosComplement y)))
+        = - (twosComplement !(!(!x + 1) & !(!y + 1)))
+        = - (twosComplement !((x - 1) & (y - 1)))
+        = - (((x - 1) & (y - 1)) + 1)
+-}
+Negative x `orInteger` Negative y = let x' = x `minusPositive` onePositive
+                                        y' = y `minusPositive` onePositive
+                                        z = x' `andDigits` y'
+                                        z' = succPositive z
+                                    in digitsToNegativeInteger z'
+
+{-# NOINLINE xorInteger #-}
+xorInteger :: Integer -> Integer -> Integer
+Naught     `xorInteger` (!i)       = i
+(!i)       `xorInteger` Naught     = i
+Positive x `xorInteger` Positive y = digitsToInteger (x `xorDigits` y)
+{-
+x ^ -y = - (twosComplement (x ^ twosComplement y))
+       = - (twosComplement !(x ^ !(twosComplement y)))
+       = - (twosComplement !(x ^ !(!y + 1)))
+       = - (twosComplement !(x ^ (y - 1)))
+       = - ((x ^ (y - 1)) + 1)
+-}
+Positive x `xorInteger` Negative y = let y' = y `minusPositive` onePositive
+                                         z = x `xorDigits` y'
+                                         z' = succPositive z
+                                     in digitsToNegativeInteger z'
+Negative x `xorInteger` Positive y = Positive y `xorInteger` Negative x
+{-
+-x ^ -y = twosComplement x ^ twosComplement y
+        = (!x + 1) ^ (!y + 1)
+        = (!x + 1) ^ (!y + 1)
+        = !(!x + 1) ^ !(!y + 1)
+        = (x - 1) ^ (y - 1)
+-}
+Negative x `xorInteger` Negative y = let x' = x `minusPositive` onePositive
+                                         y' = y `minusPositive` onePositive
+                                         z = x' `xorDigits` y'
+                                     in digitsToInteger z
+
+{-# NOINLINE complementInteger #-}
+complementInteger :: Integer -> Integer
+complementInteger x = negativeOneInteger `minusInteger` x
+
+{-# NOINLINE shiftLInteger #-}
+shiftLInteger :: Integer -> Int# -> Integer
+shiftLInteger (Positive p) i = Positive (shiftLPositive p i)
+shiftLInteger (Negative n) i = Negative (shiftLPositive n i)
+shiftLInteger Naught       _ = Naught
+
+{-# NOINLINE shiftRInteger #-}
+shiftRInteger :: Integer -> Int# -> Integer
+shiftRInteger (Positive p)   i = shiftRPositive p i
+shiftRInteger j@(Negative _) i
+    = complementInteger (shiftRInteger (complementInteger j) i)
+shiftRInteger Naught         _ = Naught
+
+twosComplementPositive :: Positive -> DigitsOnes
+twosComplementPositive p = flipBits (p `minusPositive` onePositive)
+
+flipBits :: Digits -> DigitsOnes
+flipBits ds = DigitsOnes (flipBitsDigits ds)
+
+flipBitsDigits :: Digits -> Digits
+flipBitsDigits None = None
+flipBitsDigits (Some w ws) = Some (not# w) (flipBitsDigits ws)
+
+{-# NOINLINE negateInteger #-}
+negateInteger :: Integer -> Integer
+negateInteger (Positive p) = Negative p
+negateInteger (Negative p) = Positive p
+negateInteger Naught       = Naught
+
+{-# NOINLINE plusInteger #-}
+plusInteger :: Integer -> Integer -> Integer
+Positive p1 `plusInteger` Positive p2 = Positive (p1 `plusPositive` p2)
+Negative p1 `plusInteger` Negative p2 = Negative (p1 `plusPositive` p2)
+Positive p1 `plusInteger` Negative p2 = case p1 `comparePositive` p2 of
+                                        GT -> Positive (p1 `minusPositive` p2)
+                                        EQ -> Naught
+                                        LT -> Negative (p2 `minusPositive` p1)
+Negative p1 `plusInteger` Positive p2 = Positive p2 `plusInteger` Negative p1
+Naught      `plusInteger` (!i)        = i
+(!i)        `plusInteger` Naught      = i
+
+{-# NOINLINE minusInteger #-}
+minusInteger :: Integer -> Integer -> Integer
+(!i1) `minusInteger` (!i2) = i1 `plusInteger` negateInteger i2
+
+{-# NOINLINE timesInteger #-}
+timesInteger :: Integer -> Integer -> Integer
+Positive p1 `timesInteger` Positive p2 = Positive (p1 `timesPositive` p2)
+Negative p1 `timesInteger` Negative p2 = Positive (p1 `timesPositive` p2)
+Positive p1 `timesInteger` Negative p2 = Negative (p1 `timesPositive` p2)
+Negative p1 `timesInteger` Positive p2 = Negative (p1 `timesPositive` p2)
+(!_)        `timesInteger` (!_)        = Naught
+
+{-# NOINLINE divModInteger #-}
+divModInteger :: Integer -> Integer -> (# Integer, Integer #)
+(!n) `divModInteger` (!d) =
+    case n `quotRemInteger` d of
+        (# q, r #) ->
+            if signumInteger r `eqInteger`
+               negateInteger (signumInteger d)
+            then (# q `minusInteger` oneInteger, r `plusInteger` d #)
+            else (# q, r #)
+
+{-# NOINLINE quotRemInteger #-}
+quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)
+Naught      `quotRemInteger` (!_)        = (# Naught, Naught #)
+(!_)        `quotRemInteger` Naught
+    = (# errorInteger, errorInteger #) -- XXX Can't happen
+-- XXX _            `quotRemInteger` Naught     = error "Division by zero"
+Positive p1 `quotRemInteger` Positive p2 = p1 `quotRemPositive` p2
+Negative p1 `quotRemInteger` Positive p2 = case p1 `quotRemPositive` p2 of
+                                           (# q, r #) ->
+                                               (# negateInteger q,
+                                                  negateInteger r #)
+Positive p1 `quotRemInteger` Negative p2 = case p1 `quotRemPositive` p2 of
+                                           (# q, r #) ->
+                                               (# negateInteger q, r #)
+Negative p1 `quotRemInteger` Negative p2 = case p1 `quotRemPositive` p2 of
+                                           (# q, r #) ->
+                                               (# q, negateInteger r #)
+
+{-# NOINLINE divInteger #-}
+divInteger :: Integer -> Integer -> Integer
+(!x) `divInteger` (!y) = case x `divModInteger` y of
+                    (# q, _ #) -> q
+
+{-# NOINLINE modInteger #-}
+modInteger :: Integer -> Integer -> Integer
+(!x) `modInteger` (!y) = case x `divModInteger` y of
+                    (# _, r #) -> r
+
+{-# NOINLINE quotInteger #-}
+quotInteger :: Integer -> Integer -> Integer
+(!x) `quotInteger` (!y) = case x `quotRemInteger` y of
+                    (# q, _ #) -> q
+
+{-# NOINLINE remInteger #-}
+remInteger :: Integer -> Integer -> Integer
+(!x) `remInteger` (!y) = case x `quotRemInteger` y of
+                   (# _, r #) -> r
+
+{-# NOINLINE compareInteger #-}
+compareInteger :: Integer -> Integer -> Ordering
+Positive x `compareInteger` Positive y = x `comparePositive` y
+Positive _ `compareInteger` (!_)       = GT
+Naught     `compareInteger` Naught     = EQ
+Naught     `compareInteger` Negative _ = GT
+Negative x `compareInteger` Negative y = y `comparePositive` x
+(!_)       `compareInteger` (!_)       = LT
+
+{-# NOINLINE eqInteger #-}
+eqInteger :: Integer -> Integer -> Bool
+(!x) `eqInteger` (!y) = case x `compareInteger` y of
+                  EQ -> True
+                  _ -> False
+
+{-# NOINLINE neqInteger #-}
+neqInteger :: Integer -> Integer -> Bool
+(!x) `neqInteger` (!y) = case x `compareInteger` y of
+                   EQ -> False
+                   _ -> True
+
+{-# NOINLINE ltInteger #-}
+ltInteger :: Integer -> Integer -> Bool
+(!x) `ltInteger` (!y) = case x `compareInteger` y of
+                  LT -> True
+                  _ -> False
+
+{-# NOINLINE gtInteger #-}
+gtInteger :: Integer -> Integer -> Bool
+(!x) `gtInteger` (!y) = case x `compareInteger` y of
+                  GT -> True
+                  _ -> False
+
+{-# NOINLINE leInteger #-}
+leInteger :: Integer -> Integer -> Bool
+(!x) `leInteger` (!y) = case x `compareInteger` y of
+                  GT -> False
+                  _ -> True
+
+{-# NOINLINE geInteger #-}
+geInteger :: Integer -> Integer -> Bool
+(!x) `geInteger` (!y) = case x `compareInteger` y of
+                  LT -> False
+                  _ -> True
+
+{-# NOINLINE absInteger #-}
+absInteger :: Integer -> Integer
+absInteger (Negative x) = Positive x
+absInteger (!x) = x
+
+{-# NOINLINE signumInteger #-}
+signumInteger :: Integer -> Integer
+signumInteger (Negative _) = negativeOneInteger
+signumInteger Naught       = Naught
+signumInteger (Positive _) = oneInteger
+
+-- XXX This isn't a great hash function
+{-# NOINLINE hashInteger #-}
+hashInteger :: Integer -> Int#
+hashInteger (!_) = 42#
+
+-------------------------------------------------------------------
+-- The hard work is done on positive numbers
+
+onePositive :: Positive
+onePositive = Some 1## None
+
+twoPositive :: Positive
+twoPositive = Some 2## None
+
+halfBoundUp, fullBound :: () -> Digit
+lowHalfMask :: () -> Digit
+highHalfShift :: () -> Int#
+twoToTheThirtytwoPositive :: Positive
+#if WORD_SIZE_IN_BITS == 64
+halfBoundUp   () = 0x8000000000000000##
+fullBound     () = 0xFFFFFFFFFFFFFFFF##
+lowHalfMask   () = 0xFFFFFFFF##
+highHalfShift () = 32#
+twoToTheThirtytwoPositive = Some 0x100000000## None
+#elif WORD_SIZE_IN_BITS == 32
+halfBoundUp   () = 0x80000000##
+fullBound     () = 0xFFFFFFFF##
+lowHalfMask   () = 0xFFFF##
+highHalfShift () = 16#
+twoToTheThirtytwoPositive = Some 0## (Some 1## None)
+#else
+#error Unhandled WORD_SIZE_IN_BITS
+#endif
+
+digitsMaybeZeroToInteger :: Digits -> Integer
+digitsMaybeZeroToInteger None = Naught
+digitsMaybeZeroToInteger ds = Positive ds
+
+digitsToInteger :: Digits -> Integer
+digitsToInteger ds = case removeZeroTails ds of
+                     None -> Naught
+                     ds' -> Positive ds'
+
+digitsToNegativeInteger :: Digits -> Integer
+digitsToNegativeInteger ds = case removeZeroTails ds of
+                             None -> Naught
+                             ds' -> Negative ds'
+
+removeZeroTails :: Digits -> Digits
+removeZeroTails (Some w ds) = if w `eqWord#` 0##
+                              then case removeZeroTails ds of
+                                   None -> None
+                                   ds' -> Some w ds'
+                              else Some w (removeZeroTails ds)
+removeZeroTails None = None
+
+#if WORD_SIZE_IN_BITS < 64
+word64ToPositive :: Word64# -> Positive
+word64ToPositive w
+ = if w `eqWord64#` wordToWord64# 0##
+   then None
+   else Some (word64ToWord# w) (word64ToPositive (w `uncheckedShiftRL64#` 32#))
+
+positiveToWord64 :: Positive -> Word64#
+positiveToWord64 None = wordToWord64# 0## -- XXX Can't happen
+positiveToWord64 (Some w None) = wordToWord64# w
+positiveToWord64 (Some low (Some high _))
+    = wordToWord64# low `or64#` (wordToWord64# high `uncheckedShiftL64#` 32#)
+#endif
+
+comparePositive :: Positive -> Positive -> Ordering
+Some x xs `comparePositive` Some y ys = case xs `comparePositive` ys of
+                                        EQ ->      if x `ltWord#` y then LT
+                                              else if x `gtWord#` y then GT
+                                              else                       EQ
+                                        res -> res
+None      `comparePositive` None      = EQ
+(!_)      `comparePositive` None      = GT
+None      `comparePositive` (!_)      = LT
+
+plusPositive :: Positive -> Positive -> Positive
+plusPositive x0 y0 = addWithCarry 0## x0 y0
+ where -- digit `elem` [0, 1]
+       addWithCarry :: Digit -> Positive -> Positive -> Positive
+       addWithCarry c (!xs) None  = addOnCarry c xs
+       addWithCarry c None  (!ys) = addOnCarry c ys
+       addWithCarry c xs@(Some x xs') ys@(Some y ys')
+        = if x `ltWord#` y then addWithCarry c ys xs
+          -- Now x >= y
+          else if y `geWord#` halfBoundUp ()
+               -- So they are both at least halfBoundUp, so we subtract
+               -- halfBoundUp from each and thus carry 1
+               then case x `minusWord#` halfBoundUp () of
+                    x' ->
+                     case y `minusWord#` halfBoundUp () of
+                     y' ->
+                      case x' `plusWord#` y' `plusWord#` c of
+                      this ->
+                       Some this withCarry
+          else if x `geWord#` halfBoundUp ()
+               then case x `minusWord#` halfBoundUp () of
+                    x' ->
+                     case x' `plusWord#` y `plusWord#` c of
+                     z ->
+                      -- We've taken off halfBoundUp, so now we need to
+                      -- add it back on
+                      if z `ltWord#` halfBoundUp ()
+                       then Some (z `plusWord#`  halfBoundUp ()) withoutCarry
+                       else Some (z `minusWord#` halfBoundUp ()) withCarry
+          else Some (x `plusWord#` y `plusWord#` c) withoutCarry
+           where withCarry    = addWithCarry 1## xs' ys'
+                 withoutCarry = addWithCarry 0## xs' ys'
+
+       -- digit `elem` [0, 1]
+       addOnCarry :: Digit -> Positive -> Positive
+       addOnCarry (!c) (!ws) = if c `eqWord#` 0##
+                               then ws
+                               else succPositive ws
+
+-- digit `elem` [0, 1]
+succPositive :: Positive -> Positive
+succPositive None = Some 1## None
+succPositive (Some w ws) = if w `eqWord#` fullBound ()
+                           then Some 0## (succPositive ws)
+                           else Some (w `plusWord#` 1##) ws
+
+-- Requires x > y
+-- In recursive calls, x >= y and x == y => result is None
+minusPositive :: Positive -> Positive -> Positive
+Some x xs `minusPositive` Some y ys
+ = if x `eqWord#` y
+   then case xs `minusPositive` ys of
+        None -> None
+        s -> Some 0## s
+   else if x `gtWord#` y then
+        Some (x `minusWord#` y) (xs `minusPositive` ys)
+   else case (fullBound () `minusWord#` y) `plusWord#` 1## of
+        z -> -- z = 2^n - y, calculated without overflow
+         case z `plusWord#` x of
+         z' -> -- z = 2^n + (x - y), calculated without overflow
+          Some z' ((xs `minusPositive` ys) `minusPositive` onePositive)
+(!xs) `minusPositive` None = xs
+None  `minusPositive` (!_) = errorPositive -- XXX Can't happen
+-- XXX None `minusPositive` _ = error "minusPositive: Requirement x > y not met"
+
+timesPositive :: Positive -> Positive -> Positive
+-- XXX None's can't happen here:
+None             `timesPositive` (!_)        = errorPositive
+(!_)             `timesPositive` None        = errorPositive
+-- x and y are the last digits in Positive numbers, so are not 0:
+Some x None      `timesPositive` Some y None = x `timesDigit` y
+xs@(Some _ None) `timesPositive` (!ys)       = ys `timesPositive` xs
+-- y is the last digit in a Positive number, so is not 0:
+Some x xs'       `timesPositive` ys@(Some y None)
+    = -- We could actually skip this test, and everything would
+      -- turn out OK. We already play tricks like that in timesPositive.
+      let zs = Some 0## (xs' `timesPositive` ys)
+      in if x `eqWord#` 0##
+         then zs
+         else (x `timesDigit` y) `plusPositive` zs
+Some x xs' `timesPositive` ys@(Some _ _)
+    = (Some x None `timesPositive` ys) `plusPositive`
+      Some 0## (xs' `timesPositive` ys)
+
+{-
+-- Requires arguments /= 0
+Suppose we have 2n bits in a Word. Then
+    x = 2^n xh + xl
+    y = 2^n yh + yl
+    x * y = (2^n xh + xl) * (2^n yh + yl)
+          = 2^(2n) (xh yh)
+          + 2^n    (xh yl)
+          + 2^n    (xl yh)
+          +        (xl yl)
+                   ~~~~~~~ - all fit in 2n bits
+-}
+timesDigit :: Digit -> Digit -> Positive
+timesDigit (!x) (!y)
+ = case splitHalves x of
+   (# xh, xl #) ->
+    case splitHalves y of
+    (# yh, yl #) ->
+     case xh `timesWord#` yh of
+     xhyh ->
+      case splitHalves (xh `timesWord#` yl) of
+      (# xhylh, xhyll #) ->
+       case xhyll `uncheckedShiftL#` highHalfShift () of
+       xhyll' ->
+        case splitHalves (xl `timesWord#` yh) of
+        (# xlyhh, xlyhl #) ->
+         case xlyhl `uncheckedShiftL#` highHalfShift () of
+         xlyhl' ->
+          case xl `timesWord#` yl of
+          xlyl ->
+           -- Add up all the high word results. As the result fits in
+           -- 4n bits this can't overflow.
+           case xhyh `plusWord#` xhylh `plusWord#` xlyhh of
+           high ->
+           -- low: xhyll<<n + xlyhl<<n + xlyl
+            -- From this point we might make (Some 0 None), but we know
+            -- that the final result will be positive and the addition
+            -- will work out OK, so everything will work out in the end.
+            -- One thing we do need to be careful of is avoiding returning
+            -- Some 0 (Some 0 None) + Some n None, as this will result in
+            -- Some n (Some 0 None) instead of Some n None.
+            let low = Some xhyll' None `plusPositive`
+                      Some xlyhl' None `plusPositive`
+                      Some xlyl   None
+            in if high `eqWord#` 0##
+               then low
+               else Some 0## (Some high None) `plusPositive` low
+
+splitHalves :: Digit -> (# {- High -} Digit, {- Low -} Digit #)
+splitHalves (!x) = (# x `uncheckedShiftRL#` highHalfShift (),
+                      x `and#` lowHalfMask () #)
+
+-- Assumes 0 <= i
+shiftLPositive :: Positive -> Int# -> Positive
+shiftLPositive p i
+    = if i >=# WORD_SIZE_IN_BITS#
+      then shiftLPositive (Some 0## p) (i -# WORD_SIZE_IN_BITS#)
+      else smallShiftLPositive p i
+
+-- Assumes 0 <= i < WORD_SIZE_IN_BITS#
+smallShiftLPositive :: Positive -> Int# -> Positive
+smallShiftLPositive (!p) 0# = p
+smallShiftLPositive (!p) (!i) =
+    case WORD_SIZE_IN_BITS# -# i of
+    j -> let f carry None = if carry `eqWord#` 0##
+                            then None
+                            else Some carry None
+             f carry (Some w ws) = case w `uncheckedShiftRL#` j of
+                                   carry' ->
+                                    case w `uncheckedShiftL#` i of
+                                    me ->
+                                     Some (me `or#` carry) (f carry' ws)
+         in f 0## p
+
+-- Assumes 0 <= i
+shiftRPositive :: Positive -> Int# -> Integer
+shiftRPositive None _ = Naught
+shiftRPositive p@(Some _ q) i
+    = if i >=# WORD_SIZE_IN_BITS#
+      then shiftRPositive q (i -# WORD_SIZE_IN_BITS#)
+      else smallShiftRPositive p i
+
+-- Assumes 0 <= i < WORD_SIZE_IN_BITS#
+smallShiftRPositive :: Positive -> Int# -> Integer
+smallShiftRPositive (!p) (!i) =
+    if i ==# 0#
+    then Positive p
+    else case smallShiftLPositive p (WORD_SIZE_IN_BITS# -# i) of
+         Some _ p'@(Some _ _) -> Positive p'
+         _                    -> Naught
+
+-- Long division
+quotRemPositive :: Positive -> Positive -> (# Integer, Integer #)
+(!xs) `quotRemPositive` (!ys)
+    = case f xs of
+      (# d, m #) -> (# digitsMaybeZeroToInteger d,
+                       digitsMaybeZeroToInteger m #)
+    where
+          subtractors :: Positives
+          subtractors = mkSubtractors (WORD_SIZE_IN_BITS# -# 1#)
+
+          mkSubtractors (!n) = if n ==# 0#
+                               then Cons ys Nil
+                               else Cons (ys `smallShiftLPositive` n)
+                                         (mkSubtractors (n -# 1#))
+
+          -- The main function. Go the the end of xs, then walk
+          -- back trying to divide the number we accumulate by ys.
+          f :: Positive -> (# Digits, Digits #)
+          f None = (# None, None #)
+          f (Some z zs)
+              = case f zs of
+                (# ds, m #) ->
+                    let -- We need to avoid making (Some Zero None) here
+                        m' = some z m
+                    in case g 0## subtractors m' of
+                       (# d, m'' #) ->
+                        (# some d ds, m'' #)
+
+          g :: Digit -> Positives -> Digits -> (# Digit, Digits #)
+          g (!d) Nil             (!m) = (# d, m #)
+          g (!d) (Cons sub subs) (!m)
+              = case d `uncheckedShiftL#` 1# of
+                d' ->
+                 case m `comparePositive` sub of
+                 LT -> g d' subs m
+                 _  -> g (d' `plusWord#` 1##)
+                         subs
+                         (m `minusPositive` sub)
+
+some :: Digit -> Digits -> Digits
+some (!w) None  = if w `eqWord#` 0## then None else Some w None
+some (!w) (!ws) = Some w ws
+
+andDigits :: Digits -> Digits -> Digits
+andDigits (!_)          None          = None
+andDigits None          (!_)          = None
+andDigits (Some w1 ws1) (Some w2 ws2) = Some (w1 `and#` w2) (andDigits ws1 ws2)
+
+-- DigitsOnes is just like Digits, only None is really 0xFFFFFFF...,
+-- i.e. ones off to infinity. This makes sense when we want to "and"
+-- a DigitOnes with a Digits, as the latter will bound the size of the
+-- result.
+newtype DigitsOnes = DigitsOnes Digits
+
+andDigitsOnes :: DigitsOnes -> Digits -> Digits
+andDigitsOnes (!_)                       None          = None
+andDigitsOnes (DigitsOnes None)          (!ws2)        = ws2
+andDigitsOnes (DigitsOnes (Some w1 ws1)) (Some w2 ws2)
+    = Some (w1 `and#` w2) (andDigitsOnes (DigitsOnes ws1) ws2)
+
+orDigits :: Digits -> Digits -> Digits
+orDigits None          (!ds)         = ds
+orDigits (!ds)         None          = ds
+orDigits (Some w1 ds1) (Some w2 ds2) = Some (w1 `or#` w2) (orDigits ds1 ds2)
+
+xorDigits :: Digits -> Digits -> Digits
+xorDigits None          (!ds)         = ds
+xorDigits (!ds)         None          = ds
+xorDigits (Some w1 ds1) (Some w2 ds2) = Some (w1 `xor#` w2) (xorDigits ds1 ds2)
+
+-- XXX We'd really like word2Double# for this
+doubleFromPositive :: Positive -> Double#
+doubleFromPositive None = 0.0##
+doubleFromPositive (Some w ds)
+    = case splitHalves w of
+      (# h, l #) ->
+       (doubleFromPositive ds *## (2.0## **## WORD_SIZE_IN_BITS.0##))
+       +## (int2Double# (word2Int# h) *##
+              (2.0## **## int2Double# (highHalfShift ())))
+       +## int2Double# (word2Int# l)
+
+-- XXX We'd really like word2Float# for this
+floatFromPositive :: Positive -> Float#
+floatFromPositive None = 0.0#
+floatFromPositive (Some w ds)
+    = case splitHalves w of
+      (# h, l #) ->
+       (floatFromPositive ds `timesFloat#` (2.0# `powerFloat#` WORD_SIZE_IN_BITS.0#))
+       `plusFloat#` (int2Float# (word2Int# h) `timesFloat#`
+             (2.0# `powerFloat#` int2Float# (highHalfShift ())))
+       `plusFloat#` int2Float# (word2Int# l)
+
+{-# NOINLINE zeroInteger #-}
+{-# NOINLINE oneInteger #-}
+{-# NOINLINE twoInteger #-}
+zeroInteger, oneInteger, twoInteger :: Integer
+zeroInteger = Naught
+oneInteger = Positive onePositive
+twoInteger = Positive twoPositive
+
+
+#endif
+
diff --git a/GHC/Integer/InternalsMod.hs b/GHC/Integer/InternalsMod.hs
new file mode 100644
index 0000000..bb70a9e
--- /dev/null
+++ b/GHC/Integer/InternalsMod.hs
@@ -0,0 +1,334 @@
+{-# LANGUAGE CPP, MagicHash, ForeignFunctionInterface,
+             NoImplicitPrelude, BangPatterns, UnboxedTuples,
+             UnliftedFFITypes #-}
+
+#include "MachDeps.h"
+
+module GHC.Integer.InternalsMod (
+    Integer(..), smallInteger0,
+    smallInteger, wordToInteger, integerToWord, integerToInt,
+#if WORD_SIZE_IN_BITS < 64
+    integerToWord64, integerToInt64, word64ToInteger, int64ToInteger,
+#endif
+    plusInteger, minusInteger, timesInteger, negateInteger,
+    eqInteger, neqInteger, absInteger, signumInteger,
+    leInteger, gtInteger, ltInteger, geInteger, compareInteger,
+    divInteger, modInteger,
+    divModInteger, quotRemInteger, quotInteger, remInteger,
+    encodeFloatInteger, decodeFloatInteger, floatFromInteger,
+    encodeDoubleInteger, decodeDoubleInteger, doubleFromInteger,
+    andInteger, orInteger, xorInteger, complementInteger,
+    shiftLInteger, shiftRInteger, 
+    hashInteger, zeroInteger, oneInteger, twoInteger
+ ) where
+
+import GHC.Types
+import GHC.Prim
+import GHC.Integer.TypeMod
+
+#if !defined(__HADDOCK__)
+
+smallInteger0 :: Int# -> Integer
+smallInteger0 i = Integer (int2Integer# i)
+{-# NOINLINE int2Integer# #-}
+int2Integer# :: Int# -> Int#
+int2Integer# _ = 0#
+
+smallInteger :: Int32# -> Integer
+smallInteger i = Integer (int322Integer# i)
+{-# NOINLINE int322Integer# #-}
+int322Integer# :: Int32# -> Int#
+int322Integer# _ = 0#
+
+wordToInteger :: Word# -> Integer
+wordToInteger w = Integer (word2Integer# w)
+{-# NOINLINE word2Integer# #-}
+word2Integer# :: Word# -> Int#
+word2Integer# _ = 0#
+
+#if WORD_SIZE_IN_BITS == 64
+-- Nothing
+#elif WORD_SIZE_IN_BITS == 32
+int64ToInteger :: Int64# -> Integer
+int64ToInteger i = Integer (int642Integer# i)
+{-# NOINLINE int642Integer# #-}
+int642Integer# :: Int64# -> Int#
+int642Integer# _ = 0#
+
+word64ToInteger :: Word64# -> Integer
+word64ToInteger w = Integer (word642Integer# w)
+{-# NOINLINE word642Integer# #-}
+word642Integer# :: Word64# -> Int#
+word642Integer# _ = 0#
+
+integerToWord64 :: Integer -> Word64#
+integerToWord64 (Integer i) = integer2Word64# i
+{-# NOINLINE integer2Word64# #-}
+integer2Word64# :: Int# -> Word64#
+integer2Word64# _ = indexWord64OffAddr# "        "# 0#
+
+integerToInt64 :: Integer -> Int64#
+integerToInt64 (Integer i) = integer2Int64# i
+{-# NOINLINE integer2Int64# #-}
+integer2Int64# :: Int# -> Int64#
+integer2Int64# i = int2Int64# i
+
+foreign import ccall "tolower" int2Int64# :: Int# -> Int64#
+
+#endif
+
+foreign import ccall "toupper" int2Int32# :: Int# -> Int32#
+
+integerToWord :: Integer -> Word#
+integerToWord (Integer i) = integer2Word# i
+{-# NOINLINE integer2Word# #-}
+integer2Word# :: Int# -> Word#
+integer2Word# _ = 0##
+
+integerToInt :: Integer -> Int32#
+integerToInt (Integer i) = integer2Int32# i
+{-# NOINLINE integer2Int32# #-}
+integer2Int32# :: Int# -> Int32#
+integer2Int32# i = int2Int32# i
+
+foreign import ccall "__word_encodeFloat"
+    encodeFloat# :: Word# -> Int32# -> Float#
+
+foreign import ccall "__word_encodeDouble"
+    encodeDouble# :: Word# -> Int32# -> Double#
+
+encodeDoubleInteger :: Integer -> Int32# -> Double#
+encodeDoubleInteger !i !e =
+  case compareInteger i zeroInteger of
+   GT -> 
+     let (# d, r #) = divModInteger i twoToTheThirtytwoInteger 
+         acc = if gtInteger d zeroInteger then encodeDoubleInteger d (plusInt32# e 32#) else 0.0##
+     in acc +## encodeDouble# (integerToWord r) e
+   LT -> negateDouble# (encodeDoubleInteger (negateInteger i) e)
+   EQ -> 0.0##
+
+encodeFloatInteger :: Integer -> Int32# -> Float#
+encodeFloatInteger !i !e =
+  case compareInteger i zeroInteger of
+   GT -> 
+     let (# d, r #) = divModInteger i twoToTheThirtytwoInteger 
+         acc    = if gtInteger d zeroInteger then encodeFloatInteger d (plusInt32# e 32#) else 0.0#
+     in acc `plusFloat#` encodeFloat# (integerToWord r) e
+   LT -> negateFloat# (encodeFloatInteger (negateInteger i) e)
+   EQ -> 0.0#
+
+{-# NOINLINE plusInt32# #-}
+plusInt32# :: Int32# -> Int# -> Int32#
+plusInt32# i _ = i
+
+{-# NOINLINE decodeFloatInteger #-}
+decodeFloatInteger :: Float# -> (# Integer, Int32# #)
+decodeFloatInteger f = case decodeFloat# f of
+                       (# mant, exp #) -> (# smallInteger mant, exp #)
+{-# NOINLINE decodeFloat# #-}
+decodeFloat# :: Float# -> (# Int32#, Int32# #)
+decodeFloat# _ = (# int2Int32# 0#, int2Int32# 0# #)
+
+{-# NOINLINE decodeDoubleInteger #-}
+decodeDoubleInteger :: Double# -> (# Integer, Int32# #)
+decodeDoubleInteger d
+ = case decodeDouble# d of
+   (# mantSign, mantHigh, mantLow, exp #) ->
+       (# (smallInteger mantSign) `timesInteger`
+          (  (wordToInteger mantHigh `timesInteger` twoToTheThirtytwoInteger)
+             `plusInteger` wordToInteger mantLow),
+          exp #)
+{-# NOINLINE decodeDouble# #-}
+decodeDouble# :: Double# -> (# Int32#, Word#, Word#, Int32# #)
+decodeDouble# _ = (# int2Int32# 0#, 0##, 0##, int2Int32# 0# #)
+
+doubleFromInteger :: Integer -> Double#
+doubleFromInteger (Integer i) = int2Double# i
+-- doubleFromInteger !i = encodeDoubleInteger i (integerToInt zeroInteger)
+
+floatFromInteger :: Integer -> Float#
+floatFromInteger (Integer i) = int2Float# i
+-- floatFromInteger !i = encodeFloatInteger i (integerToInt zeroInteger)
+
+andInteger :: Integer -> Integer -> Integer
+andInteger (Integer i) (Integer j) = Integer (andInt# i j)
+{-# NOINLINE andInt# #-}
+andInt# :: Int# -> Int# -> Int#
+andInt# _ _ = 0#
+
+orInteger :: Integer -> Integer -> Integer
+orInteger (Integer i) (Integer j) = Integer (orInt# i j)
+{-# NOINLINE orInt# #-}
+orInt# :: Int# -> Int# -> Int#
+orInt# _ _ = 0#
+
+xorInteger :: Integer -> Integer -> Integer
+xorInteger (Integer i) (Integer j) = Integer (xorInt# i j)
+{-# NOINLINE xorInt# #-}
+xorInt# :: Int# -> Int# -> Int#
+xorInt# _ _ = 0#
+
+{-
+andInteger :: Integer -> Integer -> Integer
+andInteger !i !j = 
+  case compare i j of
+    (EQ, _, _, _, _, _ ) -> j 
+    (_, _, _, EQ, _, _ ) -> i
+    (_, EQ, _, _, _, _ ) -> zeroInteger 
+    (_, _, _, _, EQ, _ ) -> zeroInteger
+    (_, _, EQ, _, _, EQ) -> oneInteger
+    _ -> let (# q, r #) = divModInteger i twoInteger
+             (# p, s #) = divModInteger j twoInteger
+         in plusInteger (timesInteger (andInteger q p) twoInteger) (andInteger r s)
+
+orInteger :: Integer -> Integer -> Integer
+orInteger !i !j = 
+  case compare i j of
+    (EQ, _, _, _, _, _ ) -> negativeOneInteger
+    (_, _, _, EQ, _, _ ) -> negativeOneInteger
+    (_, EQ, _, _, _, _ ) -> j
+    (_, _, _, _, EQ, _ ) -> i
+    (_, _, EQ, _, _, EQ) -> oneInteger
+    _ -> let (# q, r #) = divModInteger i twoInteger
+             (# p, s #) = divModInteger j twoInteger
+         in plusInteger (timesInteger (orInteger q p) twoInteger) (orInteger r s)
+
+xorInteger :: Integer -> Integer -> Integer
+xorInteger !i !j = 
+  case compare i j of
+    (EQ, _, _, _, _, _ ) -> complementInteger j
+    (_, _, _, EQ, _, _ ) -> complementInteger i
+    (_, EQ, _, _, _, _ ) -> j
+    (_, _, _, _, EQ, _ ) -> i
+    (_, _, EQ, _, _, EQ) -> zeroInteger
+    _ -> let (# q, r #) = divModInteger i twoInteger
+             (# p, s #) = divModInteger j twoInteger
+         in plusInteger (timesInteger (xorInteger q p) twoInteger) (xorInteger r s)
+
+compare :: Integer -> Integer -> ( Ordering, Ordering, Ordering, Ordering, Ordering, Ordering )
+compare !i !j = (compareInteger i negativeOneInteger, compareInteger i zeroInteger, compareInteger i oneInteger, 
+                 compareInteger j negativeOneInteger, compareInteger j zeroInteger, compareInteger j oneInteger)
+
+-}
+
+complementInteger :: Integer -> Integer
+complementInteger x = negativeOneInteger `minusInteger` x
+
+shiftLInteger :: Integer -> Int32# -> Integer
+--shiftLInteger = repeat (`timesInteger` twoInteger)
+shiftLInteger (Integer i) j = Integer (shiftLInteger# i (int322Integer# j))
+{-# NOINLINE shiftLInteger# #-}
+shiftLInteger# :: Int# -> Int# -> Int#
+shiftLInteger# _ _ = 0#
+
+shiftRInteger :: Integer -> Int32# -> Integer
+--shiftRInteger = repeat (`divInteger` twoInteger) 
+shiftRInteger (Integer i) j = Integer (shiftRInteger# i (int322Integer# j))
+{-# NOINLINE shiftRInteger# #-}
+shiftRInteger# :: Int# -> Int# -> Int#
+shiftRInteger# _ _ = 0#
+
+{-
+repeat :: (Integer -> Integer) -> Integer -> Int32# -> Integer
+repeat !opr !x !j = 
+  if gtInt32# j 0# then repeat opr (opr x) (minusInt32# j 1#)
+    else x
+
+{-# NOINLINE gtInt32# #-}
+gtInt32# :: Int32# -> Int# -> Bool
+gtInt32# x y = gtInt32# x y
+{-# NOINLINE minusInt32# #-}
+minusInt32# :: Int32# -> Int# -> Int32#
+minusInt32# x y = minusInt32# x y
+
+-}
+
+negateInteger :: Integer -> Integer
+negateInteger (Integer i) = Integer (negateInt# i)
+
+plusInteger :: Integer -> Integer -> Integer
+plusInteger (Integer i) (Integer j) = Integer (i +# j)
+
+minusInteger :: Integer -> Integer -> Integer
+minusInteger (Integer i) (Integer j) = Integer (i -# j)
+
+timesInteger :: Integer -> Integer -> Integer
+timesInteger (Integer i) (Integer j) = Integer (i *# j)
+
+divModInteger :: Integer -> Integer -> (# Integer, Integer #)
+n `divModInteger` d =
+    case n `quotRemInteger` d of
+        (# q, r #) ->
+            if signumInteger r `eqInteger`
+               negateInteger (signumInteger d)
+            then (# q `minusInteger` oneInteger, r `plusInteger` d #)
+            else (# q, r #)
+
+divInteger :: Integer -> Integer -> Integer
+n `divInteger` d = case n `divModInteger` d of { (# q, _ #) -> q }
+
+modInteger :: Integer -> Integer -> Integer
+n `modInteger` d = case n `divModInteger` d of { (# _, r #) -> r }
+
+quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)
+quotRemInteger !i !j = (# quotInteger i j, remInteger i j #)
+
+quotInteger :: Integer -> Integer -> Integer
+quotInteger (Integer i) (Integer j) = Integer (quotInt# i j)
+
+remInteger :: Integer -> Integer -> Integer
+remInteger (Integer i) (Integer j) = Integer (remInt# i j)
+
+{-# NOINLINE compareInteger #-}
+compareInteger :: Integer -> Integer -> Ordering
+compareInteger !i !j = if i `gtInteger` j then GT else if i `eqInteger` j then EQ else LT
+
+eqInteger :: Integer -> Integer -> Bool
+eqInteger (Integer i) (Integer j) = (==#) i j
+
+neqInteger :: Integer -> Integer -> Bool
+neqInteger (Integer i) (Integer j) = (/=#) i j
+
+ltInteger :: Integer -> Integer -> Bool
+ltInteger (Integer i) (Integer j) = (<#) i j
+
+gtInteger :: Integer -> Integer -> Bool
+gtInteger (Integer i) (Integer j) = (>#) i j
+
+leInteger :: Integer -> Integer -> Bool
+leInteger (Integer i) (Integer j) = (<=#) i j
+
+geInteger :: Integer -> Integer -> Bool
+geInteger (Integer i) (Integer j) = (>=#) i j
+
+absInteger :: Integer -> Integer
+absInteger i = if i `ltInteger` zeroInteger then negateInteger i else i
+
+signumInteger :: Integer -> Integer
+signumInteger i = case compareInteger i zeroInteger of
+                              GT -> oneInteger
+                              EQ -> zeroInteger
+                              LT -> negativeOneInteger
+
+hashInteger :: Integer -> Int32#
+hashInteger = integerToInt
+
+twoToTheThirtytwoInteger :: Integer
+twoToTheThirtytwoInteger = twoToTheSixteenInteger `timesInteger` twoToTheSixteenInteger
+
+twoToTheSixteenInteger :: Integer
+twoToTheSixteenInteger = smallInteger0 65536#
+
+oneInteger :: Integer
+oneInteger = smallInteger0 1#
+
+zeroInteger :: Integer
+zeroInteger = smallInteger0 0#
+
+twoInteger :: Integer
+twoInteger = smallInteger0 2#
+
+negativeOneInteger :: Integer
+negativeOneInteger = smallInteger0 (-1#)
+
+#endif
diff --git a/GHC/Integer/Logarithms.hs b/GHC/Integer/Logarithms.hs
index cfafe14..91c7e49 100644
--- a/GHC/Integer/Logarithms.hs
+++ b/GHC/Integer/Logarithms.hs
@@ -17,6 +17,7 @@ import qualified GHC.Integer.Logarithms.Internals as I
 -- > base ^ integerLogBase# base m <= m < base ^ (integerLogBase# base m + 1)
 --
 -- for @base > 1@ and @m > 0@.
+{-# NOINLINE integerLogBase# #-}
 integerLogBase# :: Integer -> Integer -> Int#
 integerLogBase# b m = case step b of
                         (# _, e #) -> e
@@ -35,9 +36,11 @@ integerLogBase# b m = case step b of
 --   on platforms with 32- or 64-bit words much more efficient.
 --
 --  The argument must be strictly positive, that condition is /not/ checked.
+{-# NOINLINE integerLog2# #-}
 integerLog2# :: Integer -> Int#
 integerLog2# = I.integerLog2#
 
 -- | This function calculates the integer base 2 logarithm of a 'Word#'.
+{-# NOINLINE wordLog2# #-}
 wordLog2# :: Word# -> Int#
 wordLog2# = I.wordLog2#
diff --git a/GHC/Integer/Logarithms/Internals.hs b/GHC/Integer/Logarithms/Internals.hs
index 529062a..c62cf89 100644
--- a/GHC/Integer/Logarithms/Internals.hs
+++ b/GHC/Integer/Logarithms/Internals.hs
@@ -19,6 +19,7 @@ module GHC.Integer.Logarithms.Internals
 
 import GHC.Prim
 import GHC.Integer.Type
+import GHC.Integer.Internals 
 
 default ()
 
@@ -29,6 +30,7 @@ default ()
 -- We don't know whether the word has 30 bits or 128 or even more,
 -- so we can't start from the top, although that would be much more
 -- efficient.
+{-# NOINLINE wordLog2# #-}
 wordLog2# :: Word# -> Int#
 wordLog2# w = go 8# w
   where
@@ -41,7 +43,7 @@ wordLog2# w = go 8# w
 
 -- This one at least can also be done efficiently.
 -- wordLog2# 0## = -1#
-{-# INLINE wordLog2# #-}
+{-# NOINLINE wordLog2# #-}
 wordLog2# :: Word# -> Int#
 wordLog2# w =
   case leadingZeros of
@@ -90,6 +92,7 @@ wordLog2# w =
 -- Assumption: Integer is strictly positive,
 -- otherwise return -1# arbitrarily
 -- Going up in word-sized steps should not be too bad.
+{-# NOINLINE integerLog2# #-}
 integerLog2# :: Integer -> Int#
 integerLog2# (Positive digits) = step 0# digits
   where
@@ -100,6 +103,7 @@ integerLog2# (Positive digits) = step 0# digits
 integerLog2# _ = negateInt# 1#
 
 -- Again, integer should be strictly positive
+{-# NOINLINE integerLog2IsPowerOf2# #-}
 integerLog2IsPowerOf2# :: Integer -> (# Int#, Int# #)
 integerLog2IsPowerOf2# (Positive digits) = couldBe 0# digits
   where
@@ -129,6 +133,7 @@ integerLog2IsPowerOf2# _ = (# negateInt# 1#, 1# #)
 -- 1# means we have a half-integer, round to even
 -- 2# means round up (away from zero)
 -- This function should probably be improved.
+{-# NOINLINE roundingMode# #-}
 roundingMode# :: Integer -> Int# -> Int#
 roundingMode# m h =
     case smallInteger 1# `shiftLInteger` h of
diff --git a/GHC/Integer/Logarithms/InternalsMod.hs b/GHC/Integer/Logarithms/InternalsMod.hs
new file mode 100644
index 0000000..6f9ebed
--- /dev/null
+++ b/GHC/Integer/Logarithms/InternalsMod.hs
@@ -0,0 +1,260 @@
+{-# LANGUAGE CPP, MagicHash, UnboxedTuples, NoImplicitPrelude #-}
+{-# OPTIONS_GHC -O0 #-}
+{-# OPTIONS_HADDOCK hide #-}
+
+#include "MachDeps.h"
+
+-- Fast integer logarithms to base 2.
+-- integerLog2# and wordLog2# are of general usefulness,
+-- the others are only needed for a fast implementation of
+-- fromRational.
+-- Since they are needed in GHC.Float, we must expose this
+-- module, but it should not show up in the docs.
+
+module GHC.Integer.Logarithms.InternalsMod
+    ( integerLog2#
+    , integerLog2IsPowerOf2#
+    , wordLog2#
+    , roundingMode#
+    ) where
+
+import GHC.Prim
+
+-- When larger word sizes become common, add support for those,
+-- it is not hard, just tedious.
+#if 1 
+-- (WORD_SIZE_IN_BITS != 32) && (WORD_SIZE_IN_BITS != 64)
+
+-- Less than ideal implementations for strange word sizes
+
+import GHC.Integer
+
+default ()
+
+-- We do not know whether the word has 30 bits or 128 or even more,
+-- so we cannot start from the top, although that would be much more
+-- efficient.
+-- Count the bits until the highest set bit is found.
+wordLog2# :: Word# -> Int#
+wordLog2# w = go 8# w
+  where
+    go acc u = case u `uncheckedShiftRL#` 8# of
+                0## -> case leadingZeros of
+                        BA ba -> acc -# indexInt8Array# ba (word2Int# u)
+                v   -> go (acc +# 8#) v
+
+-- Assumption: Integer is strictly positive
+integerLog2# :: Integer -> Int#
+-- integerLog2# (S# i) = wordLog2# (int2Word# i) -- that is easy
+integerLog2# m = case step m twoInteger 1# of
+                    (# _, l #) -> l
+  where
+    -- Invariants:
+    -- pw = 2 ^ lg
+    -- case step n pw lg of
+    --   (q, e) -> pw^(2*e) <= n < pw^(2*e+2)
+    --              && q <= n/pw^(2*e) < (q+1)
+    --              && q < pw^2
+    step n pw lg =
+      if n `ltInteger` pw
+        then (# n, 0# #)
+        else case step n (shiftLInteger pw lg) (2# *# lg) of
+              (# q, e #) ->
+                if q `ltInteger` pw
+                  then (# q, 2# *# e #)
+                  else (# q `shiftRInteger` lg, 2# *# e +# 1# #)
+
+-- Calculate the log2 of a positive integer and check
+-- whether it is a power of 2.
+-- By coincidence, the presence of a power of 2 is
+-- signalled by zero and not one.
+integerLog2IsPowerOf2# :: Integer -> (# Int#, Int# #)
+integerLog2IsPowerOf2# m =
+    case integerLog2# m of
+      lg -> if m `eqInteger` (oneInteger `shiftLInteger` lg)
+              then (# lg, 0# #)
+              else (# lg, 1# #)
+
+-- Detect the rounding mode,
+-- 0# means round to zero,
+-- 1# means round to even,
+-- 2# means round away from zero
+roundingMode# :: Integer -> Int# -> Int#
+roundingMode# m h =
+    case oneInteger `shiftLInteger` h of
+      c -> case m `andInteger`
+                ((c `plusInteger` c) `minusInteger` oneInteger) of
+             r ->
+               if c `ltInteger` r
+                 then 2#
+                 else if c `gtInteger` r
+                        then 0#
+                        else 1#
+
+#else
+
+default ()
+
+-- We have a nice word size, we can do much better now.
+
+#if WORD_SIZE_IN_BITS == 32
+
+#define WSHIFT 5
+#define MMASK 31
+
+#else
+
+#define WSHIFT 6
+#define MMASK 63
+
+#endif
+
+-- Assumption: Integer is strictly positive
+-- For small integers, use wordLog#,
+-- in the general case, check words from the most
+-- significant down, once a nonzero word is found,
+-- calculate its log2 and add the number of following bits.
+integerLog2# :: Integer -> Int#
+integerLog2# (S# i) = wordLog2# (int2Word# i)
+integerLog2# (J# s ba) = check (s -# 1#)
+  where
+    check i = case indexWordArray# ba i of
+                0## -> check (i -# 1#)
+                w   -> wordLog2# w +# (uncheckedIShiftL# i WSHIFT#)
+
+-- Assumption: Integer is strictly positive
+-- First component is log2 n, second is 0# iff n is a power of two
+integerLog2IsPowerOf2# :: Integer -> (# Int#, Int# #)
+-- The power of 2 test is n&(n-1) == 0, thus powers of 2
+-- are indicated bythe second component being zero.
+integerLog2IsPowerOf2# (S# i) =
+    case int2Word# i of
+      w -> (# wordLog2# w, word2Int# (w `and#` (w `minusWord#` 1##)) #)
+-- Find the log2 as above, test whether that word is a power
+-- of 2, if so, check whether only zero bits follow.
+integerLog2IsPowerOf2# (J# s ba) = check (s -# 1#)
+  where
+    check :: Int# -> (# Int#, Int# #)
+    check i = case indexWordArray# ba i of
+                0## -> check (i -# 1#)
+                w   -> (# wordLog2# w +# (uncheckedIShiftL# i WSHIFT#)
+                        , case w `and#` (w `minusWord#` 1##) of
+                            0## -> test (i -# 1#)
+                            _   -> 1# #)
+    test :: Int# -> Int#
+    test i = if i <# 0#
+                then 0#
+                else case indexWordArray# ba i of
+                        0## -> test (i -# 1#)
+                        _   -> 1#
+
+-- Assumption: Integer and Int# are strictly positive, Int# is less
+-- than logBase 2 of Integer, otherwise havoc ensues.
+-- Used only for the numerator in fromRational when the denominator
+-- is a power of 2.
+-- The Int# argument is log2 n minus the number of bits in the mantissa
+-- of the target type, i.e. the index of the first non-integral bit in
+-- the quotient.
+--
+-- 0# means round down (towards zero)
+-- 1# means we have a half-integer, round to even
+-- 2# means round up (away from zero)
+roundingMode# :: Integer -> Int# -> Int#
+roundingMode# (S# i) t =
+    case int2Word# i `and#` ((uncheckedShiftL# 2## t) `minusWord#` 1##) of
+      k -> case uncheckedShiftL# 1## t of
+            c -> if c `gtWord#` k
+                    then 0#
+                    else if c `ltWord#` k
+                            then 2#
+                            else 1#
+roundingMode# (J# _ ba) t =
+    case word2Int# (int2Word# t `and#` MMASK##) of
+      j ->      -- index of relevant bit in word
+        case uncheckedIShiftRA# t WSHIFT# of
+          k ->  -- index of relevant word
+            case indexWordArray# ba k `and#`
+                    ((uncheckedShiftL# 2## j) `minusWord#` 1##) of
+              r ->
+                case uncheckedShiftL# 1## j of
+                  c -> if c `gtWord#` r
+                        then 0#
+                        else if c `ltWord#` r
+                                then 2#
+                                else test (k -# 1#)
+  where
+    test i = if i <# 0#
+                then 1#
+                else case indexWordArray# ba i of
+                        0## -> test (i -# 1#)
+                        _   -> 2#
+
+-- wordLog2# 0## = -1#
+{-# INLINE wordLog2# #-}
+wordLog2# :: Word# -> Int#
+wordLog2# w =
+  case leadingZeros of
+   BA lz ->
+    let zeros u = indexInt8Array# lz (word2Int# u) in
+#if WORD_SIZE_IN_BITS == 64
+    case uncheckedShiftRL# w 56# of
+     a ->
+      if a `neWord#` 0##
+       then 64# -# zeros a
+       else
+        case uncheckedShiftRL# w 48# of
+         b ->
+          if b `neWord#` 0##
+           then 56# -# zeros b
+           else
+            case uncheckedShiftRL# w 40# of
+             c ->
+              if c `neWord#` 0##
+               then 48# -# zeros c
+               else
+                case uncheckedShiftRL# w 32# of
+                 d ->
+                  if d `neWord#` 0##
+                   then 40# -# zeros d
+                   else
+#endif
+                    case uncheckedShiftRL# w 24# of
+                     e ->
+                      if e `neWord#` 0##
+                       then 32# -# zeros e
+                       else
+                        case uncheckedShiftRL# w 16# of
+                         f ->
+                          if f `neWord#` 0##
+                           then 24# -# zeros f
+                           else
+                            case uncheckedShiftRL# w 8# of
+                             g ->
+                              if g `neWord#` 0##
+                               then 16# -# zeros g
+                               else 8# -# zeros w
+
+#endif
+
+-- Lookup table
+data BA = BA ByteArray#
+
+leadingZeros :: BA
+leadingZeros =
+    let mkArr s =
+          case newByteArray# 256# s of
+            (# s1, mba #) ->
+              case writeInt8Array# mba 0# 9# s1 of
+                s2 ->
+                  let fillA lim val idx st =
+                        if idx ==# 256#
+                          then st
+                          else if idx <# lim
+                                then case writeInt8Array# mba idx val st of
+                                        nx -> fillA lim val (idx +# 1#) nx
+                                else fillA (2# *# lim) (val -# 1#) idx st
+                  in case fillA 2# 8# 1# s2 of
+                      s3 -> case unsafeFreezeByteArray# mba s3 of
+                              (# _, ba #) -> ba
+    in case mkArr realWorld# of
+        b -> BA b
diff --git a/GHC/Integer/Type.hs b/GHC/Integer/Type.hs
index c3d812c..403ae85 100644
--- a/GHC/Integer/Type.hs
+++ b/GHC/Integer/Type.hs
@@ -23,15 +23,12 @@
 module GHC.Integer.Type where
 
 import GHC.Prim
-import GHC.Classes
-import GHC.Types
 import GHC.Tuple ()
 #if WORD_SIZE_IN_BITS < 64
 import GHC.IntWord64
 #endif
 
 #if !defined(__HADDOCK__)
-
 data Integer = Positive !Positive | Negative !Positive | Naught
 
 -------------------------------------------------------------------
@@ -51,809 +48,4 @@ type Digit = Word#
 -- XXX Could move [] above us
 data List a = Nil | Cons a (List a)
 
-mkInteger :: Bool   -- non-negative?
-          -> [Int]  -- absolute value in 31 bit chunks, least significant first
-                    -- ideally these would be Words rather than Ints, but
-                    -- we don't have Word available at the moment.
-          -> Integer
-mkInteger nonNegative is = let abs = f is
-                           in if nonNegative then abs else negateInteger abs
-    where f [] = Naught
-          f (I# i : is') = smallInteger i `orInteger` shiftLInteger (f is') 31#
-
-errorInteger :: Integer
-errorInteger = Positive errorPositive
-
-errorPositive :: Positive
-errorPositive = Some 47## None -- Random number
-
-{-# NOINLINE smallInteger #-}
-smallInteger :: Int# -> Integer
-smallInteger i = if i >=# 0# then wordToInteger (int2Word# i)
-                 else -- XXX is this right for -minBound?
-                      negateInteger (wordToInteger (int2Word# (negateInt# i)))
-
-{-# NOINLINE wordToInteger #-}
-wordToInteger :: Word# -> Integer
-wordToInteger w = if w `eqWord#` 0##
-                  then Naught
-                  else Positive (Some w None)
-
-{-# NOINLINE integerToWord #-}
-integerToWord :: Integer -> Word#
-integerToWord (Positive (Some w _)) = w
-integerToWord (Negative (Some w _)) = 0## `minusWord#` w
--- Must be Naught by the invariant:
-integerToWord _ = 0##
-
-{-# NOINLINE integerToInt #-}
-integerToInt :: Integer -> Int#
-integerToInt i = word2Int# (integerToWord i)
-
-#if WORD_SIZE_IN_BITS == 64
--- Nothing
-#elif WORD_SIZE_IN_BITS == 32
-{-# NOINLINE integerToWord64 #-}
-integerToWord64 :: Integer -> Word64#
-integerToWord64 i = int64ToWord64# (integerToInt64 i)
-
-{-# NOINLINE word64ToInteger #-}
-word64ToInteger:: Word64# -> Integer
-word64ToInteger w = if w `eqWord64#` wordToWord64# 0##
-                    then Naught
-                    else Positive (word64ToPositive w)
-
-{-# NOINLINE integerToInt64 #-}
-integerToInt64 :: Integer -> Int64#
-integerToInt64 Naught = intToInt64# 0#
-integerToInt64 (Positive p) = word64ToInt64# (positiveToWord64 p)
-integerToInt64 (Negative p)
-    = negateInt64# (word64ToInt64# (positiveToWord64 p))
-
-{-# NOINLINE int64ToInteger #-}
-int64ToInteger :: Int64# -> Integer
-int64ToInteger i
- = if i `eqInt64#` intToInt64# 0#
-   then Naught
-   else if i `gtInt64#` intToInt64# 0#
-   then Positive (word64ToPositive (int64ToWord64# i))
-   else Negative (word64ToPositive (int64ToWord64# (negateInt64# i)))
-#else
-#error WORD_SIZE_IN_BITS not supported
-#endif
-
-oneInteger :: Integer
-oneInteger = Positive onePositive
-
-negativeOneInteger :: Integer
-negativeOneInteger = Negative onePositive
-
-twoToTheThirtytwoInteger :: Integer
-twoToTheThirtytwoInteger = Positive twoToTheThirtytwoPositive
-
-{-# NOINLINE encodeDoubleInteger #-}
-encodeDoubleInteger :: Integer -> Int# -> Double#
-encodeDoubleInteger (Positive ds0) e0 = f 0.0## ds0 e0
-    where f !acc None        (!_) = acc
-          f !acc (Some d ds) !e   = f (acc +## encodeDouble# d e)
-                                      ds
-                                      -- XXX We assume that this adding to e
-                                      -- isn't going to overflow
-                                      (e +# WORD_SIZE_IN_BITS#)
-encodeDoubleInteger (Negative ds) e
-    = negateDouble# (encodeDoubleInteger (Positive ds) e)
-encodeDoubleInteger Naught _ = 0.0##
-
-foreign import ccall unsafe "__word_encodeDouble"
-        encodeDouble# :: Word# -> Int# -> Double#
-
-{-# NOINLINE encodeFloatInteger #-}
-encodeFloatInteger :: Integer -> Int# -> Float#
-encodeFloatInteger (Positive ds0) e0 = f 0.0# ds0 e0
-    where f !acc None        (!_) = acc
-          f !acc (Some d ds) !e   = f (acc `plusFloat#` encodeFloat# d e)
-                                      ds
-                                      -- XXX We assume that this adding to e
-                                      -- isn't going to overflow
-                                      (e +# WORD_SIZE_IN_BITS#)
-encodeFloatInteger (Negative ds) e
-    = negateFloat# (encodeFloatInteger (Positive ds) e)
-encodeFloatInteger Naught _ = 0.0#
-
-foreign import ccall unsafe "__word_encodeFloat"
-    encodeFloat# :: Word# -> Int# -> Float#
-
-{-# NOINLINE decodeFloatInteger #-}
-decodeFloatInteger :: Float# -> (# Integer, Int# #)
-decodeFloatInteger f = case decodeFloat_Int# f of
-                       (# mant, exp #) -> (# smallInteger mant, exp #)
-
--- XXX This could be optimised better, by either (word-size dependent)
--- using single 64bit value for the mantissa, or doing the multiplication
--- by just building the Digits directly
-{-# NOINLINE decodeDoubleInteger #-}
-decodeDoubleInteger :: Double# -> (# Integer, Int# #)
-decodeDoubleInteger d
- = case decodeDouble_2Int# d of
-   (# mantSign, mantHigh, mantLow, exp #) ->
-       (# (smallInteger mantSign) `timesInteger`
-          (  (wordToInteger mantHigh `timesInteger` twoToTheThirtytwoInteger)
-             `plusInteger` wordToInteger mantLow),
-          exp #)
-
-{-# NOINLINE doubleFromInteger #-}
-doubleFromInteger :: Integer -> Double#
-doubleFromInteger Naught = 0.0##
-doubleFromInteger (Positive p) = doubleFromPositive p
-doubleFromInteger (Negative p) = negateDouble# (doubleFromPositive p)
-
-{-# NOINLINE floatFromInteger #-}
-floatFromInteger :: Integer -> Float#
-floatFromInteger Naught = 0.0#
-floatFromInteger (Positive p) = floatFromPositive p
-floatFromInteger (Negative p) = negateFloat# (floatFromPositive p)
-
-{-# NOINLINE andInteger #-}
-andInteger :: Integer -> Integer -> Integer
-Naught     `andInteger` (!_)       = Naught
-(!_)       `andInteger` Naught     = Naught
-Positive x `andInteger` Positive y = digitsToInteger (x `andDigits` y)
-{-
-To calculate x & -y we need to calculate
-    x & twosComplement y
-The (imaginary) sign bits are 0 and 1, so &ing them give 0, i.e. positive.
-Note that
-    twosComplement y
-has infinitely many 1s, but x has a finite number of digits, so andDigits
-will return a finite result.
--}
-Positive x `andInteger` Negative y = let y' = twosComplementPositive y
-                                         z = y' `andDigitsOnes` x
-                                     in digitsToInteger z
-Negative x `andInteger` Positive y = Positive y `andInteger` Negative x
-{-
-To calculate -x & -y, naively we need to calculate
-    twosComplement (twosComplement x & twosComplement y)
-but
-    twosComplement x & twosComplement y
-has infinitely many 1s, so this won't work. Thus we use de Morgan's law
-to get
-    -x & -y = !(!(-x) | !(-y))
-            = !(!(twosComplement x) | !(twosComplement y))
-            = !(!(!x + 1) | (!y + 1))
-            = !((x - 1) | (y - 1))
-but the result is negative, so we need to take the two's complement of
-this in order to get the magnitude of the result.
-    twosComplement !((x - 1) | (y - 1))
-            = !(!((x - 1) | (y - 1))) + 1
-            = ((x - 1) | (y - 1)) + 1
--}
--- We don't know that x and y are /strictly/ greater than 1, but
--- minusPositive gives us the required answer anyway.
-Negative x `andInteger` Negative y = let x' = x `minusPositive` onePositive
-                                         y' = y `minusPositive` onePositive
-                                         z = x' `orDigits` y'
-                                         -- XXX Cheating the precondition:
-                                         z' = succPositive z
-                                     in digitsToNegativeInteger z'
-
-{-# NOINLINE orInteger #-}
-orInteger :: Integer -> Integer -> Integer
-Naught     `orInteger` (!i)       = i
-(!i)       `orInteger` Naught     = i
-Positive x `orInteger` Positive y = Positive (x `orDigits` y)
-{-
-x | -y = - (twosComplement (x | twosComplement y))
-       = - (twosComplement !(!x & !(twosComplement y)))
-       = - (twosComplement !(!x & !(!y + 1)))
-       = - (twosComplement !(!x & (y - 1)))
-       = - ((!x & (y - 1)) + 1)
--}
-Positive x `orInteger` Negative y = let x' = flipBits x
-                                        y' = y `minusPositive` onePositive
-                                        z = x' `andDigitsOnes` y'
-                                        z' = succPositive z
-                                    in digitsToNegativeInteger z'
-Negative x `orInteger` Positive y = Positive y `orInteger` Negative x
-{-
--x | -y = - (twosComplement (twosComplement x | twosComplement y))
-        = - (twosComplement !(!(twosComplement x) & !(twosComplement y)))
-        = - (twosComplement !(!(!x + 1) & !(!y + 1)))
-        = - (twosComplement !((x - 1) & (y - 1)))
-        = - (((x - 1) & (y - 1)) + 1)
--}
-Negative x `orInteger` Negative y = let x' = x `minusPositive` onePositive
-                                        y' = y `minusPositive` onePositive
-                                        z = x' `andDigits` y'
-                                        z' = succPositive z
-                                    in digitsToNegativeInteger z'
-
-{-# NOINLINE xorInteger #-}
-xorInteger :: Integer -> Integer -> Integer
-Naught     `xorInteger` (!i)       = i
-(!i)       `xorInteger` Naught     = i
-Positive x `xorInteger` Positive y = digitsToInteger (x `xorDigits` y)
-{-
-x ^ -y = - (twosComplement (x ^ twosComplement y))
-       = - (twosComplement !(x ^ !(twosComplement y)))
-       = - (twosComplement !(x ^ !(!y + 1)))
-       = - (twosComplement !(x ^ (y - 1)))
-       = - ((x ^ (y - 1)) + 1)
--}
-Positive x `xorInteger` Negative y = let y' = y `minusPositive` onePositive
-                                         z = x `xorDigits` y'
-                                         z' = succPositive z
-                                     in digitsToNegativeInteger z'
-Negative x `xorInteger` Positive y = Positive y `xorInteger` Negative x
-{-
--x ^ -y = twosComplement x ^ twosComplement y
-        = (!x + 1) ^ (!y + 1)
-        = (!x + 1) ^ (!y + 1)
-        = !(!x + 1) ^ !(!y + 1)
-        = (x - 1) ^ (y - 1)
--}
-Negative x `xorInteger` Negative y = let x' = x `minusPositive` onePositive
-                                         y' = y `minusPositive` onePositive
-                                         z = x' `xorDigits` y'
-                                     in digitsToInteger z
-
-{-# NOINLINE complementInteger #-}
-complementInteger :: Integer -> Integer
-complementInteger x = negativeOneInteger `minusInteger` x
-
-{-# NOINLINE shiftLInteger #-}
-shiftLInteger :: Integer -> Int# -> Integer
-shiftLInteger (Positive p) i = Positive (shiftLPositive p i)
-shiftLInteger (Negative n) i = Negative (shiftLPositive n i)
-shiftLInteger Naught       _ = Naught
-
-{-# NOINLINE shiftRInteger #-}
-shiftRInteger :: Integer -> Int# -> Integer
-shiftRInteger (Positive p)   i = shiftRPositive p i
-shiftRInteger j@(Negative _) i
-    = complementInteger (shiftRInteger (complementInteger j) i)
-shiftRInteger Naught         _ = Naught
-
-twosComplementPositive :: Positive -> DigitsOnes
-twosComplementPositive p = flipBits (p `minusPositive` onePositive)
-
-flipBits :: Digits -> DigitsOnes
-flipBits ds = DigitsOnes (flipBitsDigits ds)
-
-flipBitsDigits :: Digits -> Digits
-flipBitsDigits None = None
-flipBitsDigits (Some w ws) = Some (not# w) (flipBitsDigits ws)
-
-{-# NOINLINE negateInteger #-}
-negateInteger :: Integer -> Integer
-negateInteger (Positive p) = Negative p
-negateInteger (Negative p) = Positive p
-negateInteger Naught       = Naught
-
--- Note [Avoid patError]
-{-# NOINLINE plusInteger #-}
-plusInteger :: Integer -> Integer -> Integer
-Positive p1    `plusInteger` Positive p2 = Positive (p1 `plusPositive` p2)
-Negative p1    `plusInteger` Negative p2 = Negative (p1 `plusPositive` p2)
-Positive p1    `plusInteger` Negative p2
-    = case p1 `comparePositive` p2 of
-      GT -> Positive (p1 `minusPositive` p2)
-      EQ -> Naught
-      LT -> Negative (p2 `minusPositive` p1)
-Negative p1    `plusInteger` Positive p2
-    = Positive p2 `plusInteger` Negative p1
-Naught         `plusInteger` Naught         = Naught
-Naught         `plusInteger` i@(Positive _) = i
-Naught         `plusInteger` i@(Negative _) = i
-i@(Positive _) `plusInteger` Naught         = i
-i@(Negative _) `plusInteger` Naught         = i
-
-{-# NOINLINE minusInteger #-}
-minusInteger :: Integer -> Integer -> Integer
-i1 `minusInteger` i2 = i1 `plusInteger` negateInteger i2
-
-{-# NOINLINE timesInteger #-}
-timesInteger :: Integer -> Integer -> Integer
-Positive p1 `timesInteger` Positive p2 = Positive (p1 `timesPositive` p2)
-Negative p1 `timesInteger` Negative p2 = Positive (p1 `timesPositive` p2)
-Positive p1 `timesInteger` Negative p2 = Negative (p1 `timesPositive` p2)
-Negative p1 `timesInteger` Positive p2 = Negative (p1 `timesPositive` p2)
-(!_)        `timesInteger` (!_)        = Naught
-
-{-# NOINLINE divModInteger #-}
-divModInteger :: Integer -> Integer -> (# Integer, Integer #)
-n `divModInteger` d =
-    case n `quotRemInteger` d of
-        (# q, r #) ->
-            if signumInteger r `eqInteger`
-               negateInteger (signumInteger d)
-            then (# q `minusInteger` oneInteger, r `plusInteger` d #)
-            else (# q, r #)
-
-{-# NOINLINE quotRemInteger #-}
-quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)
-Naught      `quotRemInteger` (!_)        = (# Naught, Naught #)
-(!_)        `quotRemInteger` Naught
-    = (# errorInteger, errorInteger #) -- XXX Can't happen
--- XXX _            `quotRemInteger` Naught     = error "Division by zero"
-Positive p1 `quotRemInteger` Positive p2 = p1 `quotRemPositive` p2
-Negative p1 `quotRemInteger` Positive p2 = case p1 `quotRemPositive` p2 of
-                                           (# q, r #) ->
-                                               (# negateInteger q,
-                                                  negateInteger r #)
-Positive p1 `quotRemInteger` Negative p2 = case p1 `quotRemPositive` p2 of
-                                           (# q, r #) ->
-                                               (# negateInteger q, r #)
-Negative p1 `quotRemInteger` Negative p2 = case p1 `quotRemPositive` p2 of
-                                           (# q, r #) ->
-                                               (# q, negateInteger r #)
-
-{-# NOINLINE quotInteger #-}
-quotInteger :: Integer -> Integer -> Integer
-x `quotInteger` y = case x `quotRemInteger` y of
-                    (# q, _ #) -> q
-
-{-# NOINLINE remInteger #-}
-remInteger :: Integer -> Integer -> Integer
-x `remInteger` y = case x `quotRemInteger` y of
-                   (# _, r #) -> r
-
-{-# NOINLINE compareInteger #-}
-compareInteger :: Integer -> Integer -> Ordering
-Positive x `compareInteger` Positive y = x `comparePositive` y
-Positive _ `compareInteger` (!_)       = GT
-Naught     `compareInteger` Naught     = EQ
-Naught     `compareInteger` Negative _ = GT
-Negative x `compareInteger` Negative y = y `comparePositive` x
-(!_)       `compareInteger` (!_)       = LT
-
-{-# NOINLINE eqInteger #-}
-eqInteger :: Integer -> Integer -> Bool
-x `eqInteger` y = case x `compareInteger` y of
-                  EQ -> True
-                  _ -> False
-
-{-# NOINLINE neqInteger #-}
-neqInteger :: Integer -> Integer -> Bool
-x `neqInteger` y = case x `compareInteger` y of
-                   EQ -> False
-                   _ -> True
-
-instance  Eq Integer  where
-    (==) = eqInteger
-    (/=) = neqInteger
-
-{-# NOINLINE ltInteger #-}
-ltInteger :: Integer -> Integer -> Bool
-x `ltInteger` y = case x `compareInteger` y of
-                  LT -> True
-                  _ -> False
-
-{-# NOINLINE gtInteger #-}
-gtInteger :: Integer -> Integer -> Bool
-x `gtInteger` y = case x `compareInteger` y of
-                  GT -> True
-                  _ -> False
-
-{-# NOINLINE leInteger #-}
-leInteger :: Integer -> Integer -> Bool
-x `leInteger` y = case x `compareInteger` y of
-                  GT -> False
-                  _ -> True
-
-{-# NOINLINE geInteger #-}
-geInteger :: Integer -> Integer -> Bool
-x `geInteger` y = case x `compareInteger` y of
-                  LT -> False
-                  _ -> True
-
-instance Ord Integer where
-    (<=) = leInteger
-    (>)  = gtInteger
-    (<)  = ltInteger
-    (>=) = geInteger
-    compare = compareInteger
-
-{-# NOINLINE absInteger #-}
-absInteger :: Integer -> Integer
-absInteger (Negative x) = Positive x
-absInteger x = x
-
-{-# NOINLINE signumInteger #-}
-signumInteger :: Integer -> Integer
-signumInteger (Negative _) = negativeOneInteger
-signumInteger Naught       = Naught
-signumInteger (Positive _) = oneInteger
-
--- XXX This isn't a great hash function
-{-# NOINLINE hashInteger #-}
-hashInteger :: Integer -> Int#
-hashInteger (!_) = 42#
-
--------------------------------------------------------------------
--- The hard work is done on positive numbers
-
-onePositive :: Positive
-onePositive = Some 1## None
-
-halfBoundUp, fullBound :: () -> Digit
-lowHalfMask :: () -> Digit
-highHalfShift :: () -> Int#
-twoToTheThirtytwoPositive :: Positive
-#if WORD_SIZE_IN_BITS == 64
-halfBoundUp   () = 0x8000000000000000##
-fullBound     () = 0xFFFFFFFFFFFFFFFF##
-lowHalfMask   () = 0xFFFFFFFF##
-highHalfShift () = 32#
-twoToTheThirtytwoPositive = Some 0x100000000## None
-#elif WORD_SIZE_IN_BITS == 32
-halfBoundUp   () = 0x80000000##
-fullBound     () = 0xFFFFFFFF##
-lowHalfMask   () = 0xFFFF##
-highHalfShift () = 16#
-twoToTheThirtytwoPositive = Some 0## (Some 1## None)
-#else
-#error Unhandled WORD_SIZE_IN_BITS
 #endif
-
-digitsMaybeZeroToInteger :: Digits -> Integer
-digitsMaybeZeroToInteger None = Naught
-digitsMaybeZeroToInteger ds = Positive ds
-
-digitsToInteger :: Digits -> Integer
-digitsToInteger ds = case removeZeroTails ds of
-                     None -> Naught
-                     ds' -> Positive ds'
-
-digitsToNegativeInteger :: Digits -> Integer
-digitsToNegativeInteger ds = case removeZeroTails ds of
-                             None -> Naught
-                             ds' -> Negative ds'
-
-removeZeroTails :: Digits -> Digits
-removeZeroTails (Some w ds) = if w `eqWord#` 0##
-                              then case removeZeroTails ds of
-                                   None -> None
-                                   ds' -> Some w ds'
-                              else Some w (removeZeroTails ds)
-removeZeroTails None = None
-
-#if WORD_SIZE_IN_BITS < 64
-word64ToPositive :: Word64# -> Positive
-word64ToPositive w
- = if w `eqWord64#` wordToWord64# 0##
-   then None
-   else Some (word64ToWord# w) (word64ToPositive (w `uncheckedShiftRL64#` 32#))
-
-positiveToWord64 :: Positive -> Word64#
-positiveToWord64 None = wordToWord64# 0## -- XXX Can't happen
-positiveToWord64 (Some w None) = wordToWord64# w
-positiveToWord64 (Some low (Some high _))
-    = wordToWord64# low `or64#` (wordToWord64# high `uncheckedShiftL64#` 32#)
-#endif
-
--- Note [Avoid patError]
-comparePositive :: Positive -> Positive -> Ordering
-Some x xs `comparePositive` Some y ys = case xs `comparePositive` ys of
-                                        EQ ->      if x `ltWord#` y then LT
-                                              else if x `gtWord#` y then GT
-                                              else                       EQ
-                                        res -> res
-None      `comparePositive` None      = EQ
-(Some {}) `comparePositive` None      = GT
-None      `comparePositive` (Some {}) = LT
-
-plusPositive :: Positive -> Positive -> Positive
-plusPositive x0 y0 = addWithCarry 0## x0 y0
- where -- digit `elem` [0, 1]
-       -- Note [Avoid patError]
-       addWithCarry :: Digit -> Positive -> Positive -> Positive
-       addWithCarry c None            None            = addOnCarry c None
-       addWithCarry c xs@(Some {})    None            = addOnCarry c xs
-       addWithCarry c None            ys@(Some {})    = addOnCarry c ys
-       addWithCarry c xs@(Some x xs') ys@(Some y ys')
-        = if x `ltWord#` y then addWithCarry c ys xs
-          -- Now x >= y
-          else if y `geWord#` halfBoundUp ()
-               -- So they are both at least halfBoundUp, so we subtract
-               -- halfBoundUp from each and thus carry 1
-               then case x `minusWord#` halfBoundUp () of
-                    x' ->
-                     case y `minusWord#` halfBoundUp () of
-                     y' ->
-                      case x' `plusWord#` y' `plusWord#` c of
-                      this ->
-                       Some this withCarry
-          else if x `geWord#` halfBoundUp ()
-               then case x `minusWord#` halfBoundUp () of
-                    x' ->
-                     case x' `plusWord#` y `plusWord#` c of
-                     z ->
-                      -- We've taken off halfBoundUp, so now we need to
-                      -- add it back on
-                      if z `ltWord#` halfBoundUp ()
-                       then Some (z `plusWord#`  halfBoundUp ()) withoutCarry
-                       else Some (z `minusWord#` halfBoundUp ()) withCarry
-          else Some (x `plusWord#` y `plusWord#` c) withoutCarry
-           where withCarry    = addWithCarry 1## xs' ys'
-                 withoutCarry = addWithCarry 0## xs' ys'
-
-       -- digit `elem` [0, 1]
-       addOnCarry :: Digit -> Positive -> Positive
-       addOnCarry (!c) (!ws) = if c `eqWord#` 0##
-                               then ws
-                               else succPositive ws
-
--- digit `elem` [0, 1]
-succPositive :: Positive -> Positive
-succPositive None = Some 1## None
-succPositive (Some w ws) = if w `eqWord#` fullBound ()
-                           then Some 0## (succPositive ws)
-                           else Some (w `plusWord#` 1##) ws
-
--- Requires x > y
--- In recursive calls, x >= y and x == y => result is None
--- Note [Avoid patError]
-minusPositive :: Positive -> Positive -> Positive
-Some x xs `minusPositive` Some y ys
- = if x `eqWord#` y
-   then case xs `minusPositive` ys of
-        None -> None
-        s -> Some 0## s
-   else if x `gtWord#` y then
-        Some (x `minusWord#` y) (xs `minusPositive` ys)
-   else case (fullBound () `minusWord#` y) `plusWord#` 1## of
-        z -> -- z = 2^n - y, calculated without overflow
-         case z `plusWord#` x of
-         z' -> -- z = 2^n + (x - y), calculated without overflow
-          Some z' ((xs `minusPositive` ys) `minusPositive` onePositive)
-xs@(Some {}) `minusPositive` None      = xs
-None         `minusPositive` None      = None
-None         `minusPositive` (Some {}) = errorPositive -- XXX Can't happen
--- XXX None `minusPositive` _ = error "minusPositive: Requirement x > y not met"
-
--- Note [Avoid patError]
-timesPositive :: Positive -> Positive -> Positive
--- XXX None's can't happen here:
-None            `timesPositive` None        = errorPositive
-None            `timesPositive` (Some {})   = errorPositive
-(Some {})       `timesPositive` None        = errorPositive
--- x and y are the last digits in Positive numbers, so are not 0:
-xs@(Some x xs') `timesPositive` ys@(Some y ys')
- = case xs' of
-   None ->
-       case ys' of
-           None ->
-               x `timesDigit` y
-           Some {} ->
-               ys `timesPositive` xs
-   Some {} ->
-       case ys' of
-       None ->
-           -- y is the last digit in a Positive number, so is not 0.
-           let zs = Some 0## (xs' `timesPositive` ys)
-           in -- We could actually skip this test, and everything would
-              -- turn out OK. We already play tricks like that in timesPositive.
-              if x `eqWord#` 0##
-              then zs
-              else (x `timesDigit` y) `plusPositive` zs
-       Some {} ->
-           (Some x None `timesPositive` ys) `plusPositive`
-           Some 0## (xs' `timesPositive` ys)
-
-{-
--- Requires arguments /= 0
-Suppose we have 2n bits in a Word. Then
-    x = 2^n xh + xl
-    y = 2^n yh + yl
-    x * y = (2^n xh + xl) * (2^n yh + yl)
-          = 2^(2n) (xh yh)
-          + 2^n    (xh yl)
-          + 2^n    (xl yh)
-          +        (xl yl)
-                   ~~~~~~~ - all fit in 2n bits
--}
-timesDigit :: Digit -> Digit -> Positive
-timesDigit (!x) (!y)
- = case splitHalves x of
-   (# xh, xl #) ->
-    case splitHalves y of
-    (# yh, yl #) ->
-     case xh `timesWord#` yh of
-     xhyh ->
-      case splitHalves (xh `timesWord#` yl) of
-      (# xhylh, xhyll #) ->
-       case xhyll `uncheckedShiftL#` highHalfShift () of
-       xhyll' ->
-        case splitHalves (xl `timesWord#` yh) of
-        (# xlyhh, xlyhl #) ->
-         case xlyhl `uncheckedShiftL#` highHalfShift () of
-         xlyhl' ->
-          case xl `timesWord#` yl of
-          xlyl ->
-           -- Add up all the high word results. As the result fits in
-           -- 4n bits this can't overflow.
-           case xhyh `plusWord#` xhylh `plusWord#` xlyhh of
-           high ->
-           -- low: xhyll<<n + xlyhl<<n + xlyl
-            -- From this point we might make (Some 0 None), but we know
-            -- that the final result will be positive and the addition
-            -- will work out OK, so everything will work out in the end.
-            -- One thing we do need to be careful of is avoiding returning
-            -- Some 0 (Some 0 None) + Some n None, as this will result in
-            -- Some n (Some 0 None) instead of Some n None.
-            let low = Some xhyll' None `plusPositive`
-                      Some xlyhl' None `plusPositive`
-                      Some xlyl   None
-            in if high `eqWord#` 0##
-               then low
-               else Some 0## (Some high None) `plusPositive` low
-
-splitHalves :: Digit -> (# {- High -} Digit, {- Low -} Digit #)
-splitHalves (!x) = (# x `uncheckedShiftRL#` highHalfShift (),
-                      x `and#` lowHalfMask () #)
-
--- Assumes 0 <= i
-shiftLPositive :: Positive -> Int# -> Positive
-shiftLPositive p i
-    = if i >=# WORD_SIZE_IN_BITS#
-      then shiftLPositive (Some 0## p) (i -# WORD_SIZE_IN_BITS#)
-      else smallShiftLPositive p i
-
--- Assumes 0 <= i < WORD_SIZE_IN_BITS#
-smallShiftLPositive :: Positive -> Int# -> Positive
-smallShiftLPositive (!p) 0# = p
-smallShiftLPositive (!p) (!i) =
-    case WORD_SIZE_IN_BITS# -# i of
-    j -> let f carry None = if carry `eqWord#` 0##
-                            then None
-                            else Some carry None
-             f carry (Some w ws) = case w `uncheckedShiftRL#` j of
-                                   carry' ->
-                                    case w `uncheckedShiftL#` i of
-                                    me ->
-                                     Some (me `or#` carry) (f carry' ws)
-         in f 0## p
-
--- Assumes 0 <= i
-shiftRPositive :: Positive -> Int# -> Integer
-shiftRPositive None _ = Naught
-shiftRPositive p@(Some _ q) i
-    = if i >=# WORD_SIZE_IN_BITS#
-      then shiftRPositive q (i -# WORD_SIZE_IN_BITS#)
-      else smallShiftRPositive p i
-
--- Assumes 0 <= i < WORD_SIZE_IN_BITS#
-smallShiftRPositive :: Positive -> Int# -> Integer
-smallShiftRPositive (!p) (!i) =
-    if i ==# 0#
-    then Positive p
-    else case smallShiftLPositive p (WORD_SIZE_IN_BITS# -# i) of
-         Some _ p'@(Some _ _) -> Positive p'
-         _                    -> Naught
-
--- Long division
-quotRemPositive :: Positive -> Positive -> (# Integer, Integer #)
-(!xs) `quotRemPositive` (!ys)
-    = case f xs of
-      (# d, m #) -> (# digitsMaybeZeroToInteger d,
-                       digitsMaybeZeroToInteger m #)
-    where
-          subtractors :: Positives
-          subtractors = mkSubtractors (WORD_SIZE_IN_BITS# -# 1#)
-
-          mkSubtractors (!n) = if n ==# 0#
-                               then Cons ys Nil
-                               else Cons (ys `smallShiftLPositive` n)
-                                         (mkSubtractors (n -# 1#))
-
-          -- The main function. Go the the end of xs, then walk
-          -- back trying to divide the number we accumulate by ys.
-          f :: Positive -> (# Digits, Digits #)
-          f None = (# None, None #)
-          f (Some z zs)
-              = case f zs of
-                (# ds, m #) ->
-                    let -- We need to avoid making (Some Zero None) here
-                        m' = some z m
-                    in case g 0## subtractors m' of
-                       (# d, m'' #) ->
-                        (# some d ds, m'' #)
-
-          g :: Digit -> Positives -> Digits -> (# Digit, Digits #)
-          g (!d) Nil             (!m) = (# d, m #)
-          g (!d) (Cons sub subs) (!m)
-              = case d `uncheckedShiftL#` 1# of
-                d' ->
-                 case m `comparePositive` sub of
-                 LT -> g d' subs m
-                 _  -> g (d' `plusWord#` 1##)
-                         subs
-                         (m `minusPositive` sub)
-
-some :: Digit -> Digits -> Digits
-some (!w) None  = if w `eqWord#` 0## then None else Some w None
-some (!w) (!ws) = Some w ws
-
--- Note [Avoid patError]
-andDigits :: Digits -> Digits -> Digits
-andDigits None          None          = None
-andDigits (Some {})     None          = None
-andDigits None          (Some {})     = None
-andDigits (Some w1 ws1) (Some w2 ws2) = Some (w1 `and#` w2) (andDigits ws1 ws2)
-
--- DigitsOnes is just like Digits, only None is really 0xFFFFFFF...,
--- i.e. ones off to infinity. This makes sense when we want to "and"
--- a DigitOnes with a Digits, as the latter will bound the size of the
--- result.
-newtype DigitsOnes = DigitsOnes Digits
-
--- Note [Avoid patError]
-andDigitsOnes :: DigitsOnes -> Digits -> Digits
-andDigitsOnes (DigitsOnes None)          None          = None
-andDigitsOnes (DigitsOnes None)          ws2@(Some {}) = ws2
-andDigitsOnes (DigitsOnes (Some {}))     None          = None
-andDigitsOnes (DigitsOnes (Some w1 ws1)) (Some w2 ws2)
-    = Some (w1 `and#` w2) (andDigitsOnes (DigitsOnes ws1) ws2)
-
--- Note [Avoid patError]
-orDigits :: Digits -> Digits -> Digits
-orDigits None          None          = None
-orDigits None          ds@(Some {})  = ds
-orDigits ds@(Some {})  None          = ds
-orDigits (Some w1 ds1) (Some w2 ds2) = Some (w1 `or#` w2) (orDigits ds1 ds2)
-
--- Note [Avoid patError]
-xorDigits :: Digits -> Digits -> Digits
-xorDigits None          None          = None
-xorDigits None          ds@(Some {})  = ds
-xorDigits ds@(Some {})  None          = ds
-xorDigits (Some w1 ds1) (Some w2 ds2) = Some (w1 `xor#` w2) (xorDigits ds1 ds2)
-
--- XXX We'd really like word2Double# for this
-doubleFromPositive :: Positive -> Double#
-doubleFromPositive None = 0.0##
-doubleFromPositive (Some w ds)
-    = case splitHalves w of
-      (# h, l #) ->
-       (doubleFromPositive ds *## (2.0## **## WORD_SIZE_IN_BITS.0##))
-       +## (int2Double# (word2Int# h) *##
-              (2.0## **## int2Double# (highHalfShift ())))
-       +## int2Double# (word2Int# l)
-
--- XXX We'd really like word2Float# for this
-floatFromPositive :: Positive -> Float#
-floatFromPositive None = 0.0#
-floatFromPositive (Some w ds)
-    = case splitHalves w of
-      (# h, l #) ->
-       (floatFromPositive ds `timesFloat#` (2.0# `powerFloat#` WORD_SIZE_IN_BITS.0#))
-       `plusFloat#` (int2Float# (word2Int# h) `timesFloat#`
-             (2.0# `powerFloat#` int2Float# (highHalfShift ())))
-       `plusFloat#` int2Float# (word2Int# l)
-
-#endif
-
-{-
-Note [Avoid patError]
-
-If we use the natural set of definitions for functions, e.g.:
-
-    orDigits None          ds            = ds
-    orDigits ds            None          = ds
-    orDigits (Some w1 ds1) (Some w2 ds2) = Some ... ...
-
-then GHC may not be smart enough (especially when compiling with -O0)
-to see that all the cases are handled, and will thus insert calls to
-base:Control.Exception.Base.patError. But we are below base in the
-package hierarchy, so this causes build failure!
-
-We therefore help GHC out, by being more explicit about what all the
-cases are:
-
-    orDigits None          None          = None
-    orDigits None          ds@(Some {})  = ds
-    orDigits ds@(Some {})  None          = ds
-    orDigits (Some w1 ds1) (Some w2 ds2) = Some ... ...
--}
-
diff --git a/GHC/Integer/TypeMod.hs b/GHC/Integer/TypeMod.hs
new file mode 100644
index 0000000..8f0e987
--- /dev/null
+++ b/GHC/Integer/TypeMod.hs
@@ -0,0 +1,5 @@
+{-# LANGUAGE NoImplicitPrelude #-}
+
+module GHC.Integer.TypeMod where
+import GHC.Prim
+data Integer = Integer Int#
diff --git a/integer-simple.cabal b/integer-simple.cabal
index 091c1b8..32f1ae5 100644
--- a/integer-simple.cabal
+++ b/integer-simple.cabal
@@ -16,10 +16,11 @@ source-repository head
 Library {
     build-depends: ghc-prim
     exposed-modules: GHC.Integer
-                     GHC.Integer.Simple.Internals
                      GHC.Integer.Logarithms
                      GHC.Integer.Logarithms.Internals
-    other-modules: GHC.Integer.Type
+                     GHC.Integer.Logarithms.InternalsMod
+    other-modules: GHC.Integer.Type GHC.Integer.TypeMod 
+                   GHC.Integer.Internals GHC.Integer.InternalsMod
     extensions: CPP, MagicHash, BangPatterns, UnboxedTuples,
                 ForeignFunctionInterface, UnliftedFFITypes,
                 NoImplicitPrelude
